// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"server/infrastructure/ent/board"
	"server/infrastructure/ent/comment"
	"server/infrastructure/ent/commentattachment"
	"server/infrastructure/ent/predicate"
	"server/infrastructure/ent/thread"
	"server/infrastructure/ent/threadtag"
	"server/infrastructure/ent/threadtagging"
	"server/infrastructure/ent/user"
	"server/infrastructure/ent/userboardlike"
	"server/infrastructure/ent/userboardsubscription"
	"server/infrastructure/ent/usercommentlike"
	"server/infrastructure/ent/usercommentsubscription"
	"server/infrastructure/ent/userthreadlike"
	"server/infrastructure/ent/userthreadsubscription"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBoard                   = "Board"
	TypeComment                 = "Comment"
	TypeCommentAttachment       = "CommentAttachment"
	TypeThread                  = "Thread"
	TypeThreadTag               = "ThreadTag"
	TypeThreadTagging           = "ThreadTagging"
	TypeUser                    = "User"
	TypeUserBoardLike           = "UserBoardLike"
	TypeUserBoardSubscription   = "UserBoardSubscription"
	TypeUserCommentLike         = "UserCommentLike"
	TypeUserCommentSubscription = "UserCommentSubscription"
	TypeUserThreadLike          = "UserThreadLike"
	TypeUserThreadSubscription  = "UserThreadSubscription"
)

// BoardMutation represents an operation that mutates the Board nodes in the graph.
type BoardMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	title                   *string
	description             *string
	thumbnailUrl            *string
	status                  *int
	addstatus               *int
	createdAt               *time.Time
	updatedAt               *time.Time
	clearedFields           map[string]struct{}
	liked_users             map[int]struct{}
	removedliked_users      map[int]struct{}
	clearedliked_users      bool
	subscribed_users        map[int]struct{}
	removedsubscribed_users map[int]struct{}
	clearedsubscribed_users bool
	owner                   *int
	clearedowner            bool
	threads                 map[int]struct{}
	removedthreads          map[int]struct{}
	clearedthreads          bool
	done                    bool
	oldValue                func(context.Context) (*Board, error)
	predicates              []predicate.Board
}

var _ ent.Mutation = (*BoardMutation)(nil)

// boardOption allows management of the mutation configuration using functional options.
type boardOption func(*BoardMutation)

// newBoardMutation creates new mutation for the Board entity.
func newBoardMutation(c config, op Op, opts ...boardOption) *BoardMutation {
	m := &BoardMutation{
		config:        c,
		op:            op,
		typ:           TypeBoard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBoardID sets the ID field of the mutation.
func withBoardID(id int) boardOption {
	return func(m *BoardMutation) {
		var (
			err   error
			once  sync.Once
			value *Board
		)
		m.oldValue = func(ctx context.Context) (*Board, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Board.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBoard sets the old Board of the mutation.
func withBoard(node *Board) boardOption {
	return func(m *BoardMutation) {
		m.oldValue = func(context.Context) (*Board, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BoardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BoardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Board entities.
func (m *BoardMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BoardMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BoardMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Board.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *BoardMutation) SetUserId(i int) {
	m.owner = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *BoardMutation) UserId() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldUserId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *BoardMutation) ResetUserId() {
	m.owner = nil
}

// SetTitle sets the "title" field.
func (m *BoardMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BoardMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BoardMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BoardMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BoardMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BoardMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[board.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BoardMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[board.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BoardMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, board.FieldDescription)
}

// SetThumbnailUrl sets the "thumbnailUrl" field.
func (m *BoardMutation) SetThumbnailUrl(s string) {
	m.thumbnailUrl = &s
}

// ThumbnailUrl returns the value of the "thumbnailUrl" field in the mutation.
func (m *BoardMutation) ThumbnailUrl() (r string, exists bool) {
	v := m.thumbnailUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailUrl returns the old "thumbnailUrl" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldThumbnailUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailUrl: %w", err)
	}
	return oldValue.ThumbnailUrl, nil
}

// ClearThumbnailUrl clears the value of the "thumbnailUrl" field.
func (m *BoardMutation) ClearThumbnailUrl() {
	m.thumbnailUrl = nil
	m.clearedFields[board.FieldThumbnailUrl] = struct{}{}
}

// ThumbnailUrlCleared returns if the "thumbnailUrl" field was cleared in this mutation.
func (m *BoardMutation) ThumbnailUrlCleared() bool {
	_, ok := m.clearedFields[board.FieldThumbnailUrl]
	return ok
}

// ResetThumbnailUrl resets all changes to the "thumbnailUrl" field.
func (m *BoardMutation) ResetThumbnailUrl() {
	m.thumbnailUrl = nil
	delete(m.clearedFields, board.FieldThumbnailUrl)
}

// SetStatus sets the "status" field.
func (m *BoardMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BoardMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BoardMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BoardMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *BoardMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *BoardMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *BoardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *BoardMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *BoardMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *BoardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *BoardMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// AddLikedUserIDs adds the "liked_users" edge to the User entity by ids.
func (m *BoardMutation) AddLikedUserIDs(ids ...int) {
	if m.liked_users == nil {
		m.liked_users = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_users[ids[i]] = struct{}{}
	}
}

// ClearLikedUsers clears the "liked_users" edge to the User entity.
func (m *BoardMutation) ClearLikedUsers() {
	m.clearedliked_users = true
}

// LikedUsersCleared reports if the "liked_users" edge to the User entity was cleared.
func (m *BoardMutation) LikedUsersCleared() bool {
	return m.clearedliked_users
}

// RemoveLikedUserIDs removes the "liked_users" edge to the User entity by IDs.
func (m *BoardMutation) RemoveLikedUserIDs(ids ...int) {
	if m.removedliked_users == nil {
		m.removedliked_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_users, ids[i])
		m.removedliked_users[ids[i]] = struct{}{}
	}
}

// RemovedLikedUsers returns the removed IDs of the "liked_users" edge to the User entity.
func (m *BoardMutation) RemovedLikedUsersIDs() (ids []int) {
	for id := range m.removedliked_users {
		ids = append(ids, id)
	}
	return
}

// LikedUsersIDs returns the "liked_users" edge IDs in the mutation.
func (m *BoardMutation) LikedUsersIDs() (ids []int) {
	for id := range m.liked_users {
		ids = append(ids, id)
	}
	return
}

// ResetLikedUsers resets all changes to the "liked_users" edge.
func (m *BoardMutation) ResetLikedUsers() {
	m.liked_users = nil
	m.clearedliked_users = false
	m.removedliked_users = nil
}

// AddSubscribedUserIDs adds the "subscribed_users" edge to the User entity by ids.
func (m *BoardMutation) AddSubscribedUserIDs(ids ...int) {
	if m.subscribed_users == nil {
		m.subscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_users[ids[i]] = struct{}{}
	}
}

// ClearSubscribedUsers clears the "subscribed_users" edge to the User entity.
func (m *BoardMutation) ClearSubscribedUsers() {
	m.clearedsubscribed_users = true
}

// SubscribedUsersCleared reports if the "subscribed_users" edge to the User entity was cleared.
func (m *BoardMutation) SubscribedUsersCleared() bool {
	return m.clearedsubscribed_users
}

// RemoveSubscribedUserIDs removes the "subscribed_users" edge to the User entity by IDs.
func (m *BoardMutation) RemoveSubscribedUserIDs(ids ...int) {
	if m.removedsubscribed_users == nil {
		m.removedsubscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_users, ids[i])
		m.removedsubscribed_users[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedUsers returns the removed IDs of the "subscribed_users" edge to the User entity.
func (m *BoardMutation) RemovedSubscribedUsersIDs() (ids []int) {
	for id := range m.removedsubscribed_users {
		ids = append(ids, id)
	}
	return
}

// SubscribedUsersIDs returns the "subscribed_users" edge IDs in the mutation.
func (m *BoardMutation) SubscribedUsersIDs() (ids []int) {
	for id := range m.subscribed_users {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedUsers resets all changes to the "subscribed_users" edge.
func (m *BoardMutation) ResetSubscribedUsers() {
	m.subscribed_users = nil
	m.clearedsubscribed_users = false
	m.removedsubscribed_users = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *BoardMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *BoardMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[board.FieldUserId] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *BoardMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *BoardMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *BoardMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *BoardMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *BoardMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *BoardMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *BoardMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *BoardMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *BoardMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *BoardMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *BoardMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// Where appends a list predicates to the BoardMutation builder.
func (m *BoardMutation) Where(ps ...predicate.Board) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BoardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BoardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Board, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BoardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BoardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Board).
func (m *BoardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BoardMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.owner != nil {
		fields = append(fields, board.FieldUserId)
	}
	if m.title != nil {
		fields = append(fields, board.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, board.FieldDescription)
	}
	if m.thumbnailUrl != nil {
		fields = append(fields, board.FieldThumbnailUrl)
	}
	if m.status != nil {
		fields = append(fields, board.FieldStatus)
	}
	if m.createdAt != nil {
		fields = append(fields, board.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, board.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BoardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case board.FieldUserId:
		return m.UserId()
	case board.FieldTitle:
		return m.Title()
	case board.FieldDescription:
		return m.Description()
	case board.FieldThumbnailUrl:
		return m.ThumbnailUrl()
	case board.FieldStatus:
		return m.Status()
	case board.FieldCreatedAt:
		return m.CreatedAt()
	case board.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BoardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case board.FieldUserId:
		return m.OldUserId(ctx)
	case board.FieldTitle:
		return m.OldTitle(ctx)
	case board.FieldDescription:
		return m.OldDescription(ctx)
	case board.FieldThumbnailUrl:
		return m.OldThumbnailUrl(ctx)
	case board.FieldStatus:
		return m.OldStatus(ctx)
	case board.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case board.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Board field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BoardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case board.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case board.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case board.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case board.FieldThumbnailUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailUrl(v)
		return nil
	case board.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case board.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case board.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Board field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BoardMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, board.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BoardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case board.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BoardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case board.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Board numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BoardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(board.FieldDescription) {
		fields = append(fields, board.FieldDescription)
	}
	if m.FieldCleared(board.FieldThumbnailUrl) {
		fields = append(fields, board.FieldThumbnailUrl)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BoardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BoardMutation) ClearField(name string) error {
	switch name {
	case board.FieldDescription:
		m.ClearDescription()
		return nil
	case board.FieldThumbnailUrl:
		m.ClearThumbnailUrl()
		return nil
	}
	return fmt.Errorf("unknown Board nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BoardMutation) ResetField(name string) error {
	switch name {
	case board.FieldUserId:
		m.ResetUserId()
		return nil
	case board.FieldTitle:
		m.ResetTitle()
		return nil
	case board.FieldDescription:
		m.ResetDescription()
		return nil
	case board.FieldThumbnailUrl:
		m.ResetThumbnailUrl()
		return nil
	case board.FieldStatus:
		m.ResetStatus()
		return nil
	case board.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case board.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Board field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BoardMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.liked_users != nil {
		edges = append(edges, board.EdgeLikedUsers)
	}
	if m.subscribed_users != nil {
		edges = append(edges, board.EdgeSubscribedUsers)
	}
	if m.owner != nil {
		edges = append(edges, board.EdgeOwner)
	}
	if m.threads != nil {
		edges = append(edges, board.EdgeThreads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BoardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case board.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.liked_users))
		for id := range m.liked_users {
			ids = append(ids, id)
		}
		return ids
	case board.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.subscribed_users))
		for id := range m.subscribed_users {
			ids = append(ids, id)
		}
		return ids
	case board.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case board.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BoardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedliked_users != nil {
		edges = append(edges, board.EdgeLikedUsers)
	}
	if m.removedsubscribed_users != nil {
		edges = append(edges, board.EdgeSubscribedUsers)
	}
	if m.removedthreads != nil {
		edges = append(edges, board.EdgeThreads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BoardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case board.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.removedliked_users))
		for id := range m.removedliked_users {
			ids = append(ids, id)
		}
		return ids
	case board.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_users))
		for id := range m.removedsubscribed_users {
			ids = append(ids, id)
		}
		return ids
	case board.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BoardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedliked_users {
		edges = append(edges, board.EdgeLikedUsers)
	}
	if m.clearedsubscribed_users {
		edges = append(edges, board.EdgeSubscribedUsers)
	}
	if m.clearedowner {
		edges = append(edges, board.EdgeOwner)
	}
	if m.clearedthreads {
		edges = append(edges, board.EdgeThreads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BoardMutation) EdgeCleared(name string) bool {
	switch name {
	case board.EdgeLikedUsers:
		return m.clearedliked_users
	case board.EdgeSubscribedUsers:
		return m.clearedsubscribed_users
	case board.EdgeOwner:
		return m.clearedowner
	case board.EdgeThreads:
		return m.clearedthreads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BoardMutation) ClearEdge(name string) error {
	switch name {
	case board.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Board unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BoardMutation) ResetEdge(name string) error {
	switch name {
	case board.EdgeLikedUsers:
		m.ResetLikedUsers()
		return nil
	case board.EdgeSubscribedUsers:
		m.ResetSubscribedUsers()
		return nil
	case board.EdgeOwner:
		m.ResetOwner()
		return nil
	case board.EdgeThreads:
		m.ResetThreads()
		return nil
	}
	return fmt.Errorf("unknown Board edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	guestName                  *string
	message                    *string
	ip_address                 *string
	status                     *int
	addstatus                  *int
	createdAt                  *time.Time
	updatedAt                  *time.Time
	clearedFields              map[string]struct{}
	thread                     *int
	clearedthread              bool
	author                     *int
	clearedauthor              bool
	parent_comment             *int
	clearedparent_comment      bool
	replies                    map[int]struct{}
	removedreplies             map[int]struct{}
	clearedreplies             bool
	comment_attachments        map[int]struct{}
	removedcomment_attachments map[int]struct{}
	clearedcomment_attachments bool
	liked_users                map[int]struct{}
	removedliked_users         map[int]struct{}
	clearedliked_users         bool
	subscribed_users           map[int]struct{}
	removedsubscribed_users    map[int]struct{}
	clearedsubscribed_users    bool
	done                       bool
	oldValue                   func(context.Context) (*Comment, error)
	predicates                 []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetThreadId sets the "threadId" field.
func (m *CommentMutation) SetThreadId(i int) {
	m.thread = &i
}

// ThreadId returns the value of the "threadId" field in the mutation.
func (m *CommentMutation) ThreadId() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// OldThreadId returns the old "threadId" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldThreadId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreadId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreadId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreadId: %w", err)
	}
	return oldValue.ThreadId, nil
}

// ResetThreadId resets all changes to the "threadId" field.
func (m *CommentMutation) ResetThreadId() {
	m.thread = nil
}

// SetParentCommentId sets the "parentCommentId" field.
func (m *CommentMutation) SetParentCommentId(i int) {
	m.parent_comment = &i
}

// ParentCommentId returns the value of the "parentCommentId" field in the mutation.
func (m *CommentMutation) ParentCommentId() (r int, exists bool) {
	v := m.parent_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldParentCommentId returns the old "parentCommentId" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentCommentId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentCommentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentCommentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentCommentId: %w", err)
	}
	return oldValue.ParentCommentId, nil
}

// ClearParentCommentId clears the value of the "parentCommentId" field.
func (m *CommentMutation) ClearParentCommentId() {
	m.parent_comment = nil
	m.clearedFields[comment.FieldParentCommentId] = struct{}{}
}

// ParentCommentIdCleared returns if the "parentCommentId" field was cleared in this mutation.
func (m *CommentMutation) ParentCommentIdCleared() bool {
	_, ok := m.clearedFields[comment.FieldParentCommentId]
	return ok
}

// ResetParentCommentId resets all changes to the "parentCommentId" field.
func (m *CommentMutation) ResetParentCommentId() {
	m.parent_comment = nil
	delete(m.clearedFields, comment.FieldParentCommentId)
}

// SetUserId sets the "userId" field.
func (m *CommentMutation) SetUserId(i int) {
	m.author = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *CommentMutation) UserId() (r int, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ClearUserId clears the value of the "userId" field.
func (m *CommentMutation) ClearUserId() {
	m.author = nil
	m.clearedFields[comment.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "userId" field was cleared in this mutation.
func (m *CommentMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "userId" field.
func (m *CommentMutation) ResetUserId() {
	m.author = nil
	delete(m.clearedFields, comment.FieldUserId)
}

// SetGuestName sets the "guestName" field.
func (m *CommentMutation) SetGuestName(s string) {
	m.guestName = &s
}

// GuestName returns the value of the "guestName" field in the mutation.
func (m *CommentMutation) GuestName() (r string, exists bool) {
	v := m.guestName
	if v == nil {
		return
	}
	return *v, true
}

// OldGuestName returns the old "guestName" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldGuestName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuestName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuestName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuestName: %w", err)
	}
	return oldValue.GuestName, nil
}

// ClearGuestName clears the value of the "guestName" field.
func (m *CommentMutation) ClearGuestName() {
	m.guestName = nil
	m.clearedFields[comment.FieldGuestName] = struct{}{}
}

// GuestNameCleared returns if the "guestName" field was cleared in this mutation.
func (m *CommentMutation) GuestNameCleared() bool {
	_, ok := m.clearedFields[comment.FieldGuestName]
	return ok
}

// ResetGuestName resets all changes to the "guestName" field.
func (m *CommentMutation) ResetGuestName() {
	m.guestName = nil
	delete(m.clearedFields, comment.FieldGuestName)
}

// SetMessage sets the "message" field.
func (m *CommentMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CommentMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *CommentMutation) ResetMessage() {
	m.message = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *CommentMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *CommentMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *CommentMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetStatus sets the "status" field.
func (m *CommentMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CommentMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CommentMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CommentMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CommentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetThreadID sets the "thread" edge to the Thread entity by id.
func (m *CommentMutation) SetThreadID(id int) {
	m.thread = &id
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *CommentMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[comment.FieldThreadId] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *CommentMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadID returns the "thread" edge ID in the mutation.
func (m *CommentMutation) ThreadID() (id int, exists bool) {
	if m.thread != nil {
		return *m.thread, true
	}
	return
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *CommentMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *CommentMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *CommentMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[comment.FieldUserId] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *CommentMutation) AuthorCleared() bool {
	return m.UserIdCleared() || m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *CommentMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *CommentMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetParentCommentID sets the "parent_comment" edge to the Comment entity by id.
func (m *CommentMutation) SetParentCommentID(id int) {
	m.parent_comment = &id
}

// ClearParentComment clears the "parent_comment" edge to the Comment entity.
func (m *CommentMutation) ClearParentComment() {
	m.clearedparent_comment = true
	m.clearedFields[comment.FieldParentCommentId] = struct{}{}
}

// ParentCommentCleared reports if the "parent_comment" edge to the Comment entity was cleared.
func (m *CommentMutation) ParentCommentCleared() bool {
	return m.ParentCommentIdCleared() || m.clearedparent_comment
}

// ParentCommentID returns the "parent_comment" edge ID in the mutation.
func (m *CommentMutation) ParentCommentID() (id int, exists bool) {
	if m.parent_comment != nil {
		return *m.parent_comment, true
	}
	return
}

// ParentCommentIDs returns the "parent_comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentCommentID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ParentCommentIDs() (ids []int) {
	if id := m.parent_comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentComment resets all changes to the "parent_comment" edge.
func (m *CommentMutation) ResetParentComment() {
	m.parent_comment = nil
	m.clearedparent_comment = false
}

// AddReplyIDs adds the "replies" edge to the Comment entity by ids.
func (m *CommentMutation) AddReplyIDs(ids ...int) {
	if m.replies == nil {
		m.replies = make(map[int]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the Comment entity.
func (m *CommentMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the Comment entity was cleared.
func (m *CommentMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the Comment entity by IDs.
func (m *CommentMutation) RemoveReplyIDs(ids ...int) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the Comment entity.
func (m *CommentMutation) RemovedRepliesIDs() (ids []int) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *CommentMutation) RepliesIDs() (ids []int) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *CommentMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// AddCommentAttachmentIDs adds the "comment_attachments" edge to the CommentAttachment entity by ids.
func (m *CommentMutation) AddCommentAttachmentIDs(ids ...int) {
	if m.comment_attachments == nil {
		m.comment_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.comment_attachments[ids[i]] = struct{}{}
	}
}

// ClearCommentAttachments clears the "comment_attachments" edge to the CommentAttachment entity.
func (m *CommentMutation) ClearCommentAttachments() {
	m.clearedcomment_attachments = true
}

// CommentAttachmentsCleared reports if the "comment_attachments" edge to the CommentAttachment entity was cleared.
func (m *CommentMutation) CommentAttachmentsCleared() bool {
	return m.clearedcomment_attachments
}

// RemoveCommentAttachmentIDs removes the "comment_attachments" edge to the CommentAttachment entity by IDs.
func (m *CommentMutation) RemoveCommentAttachmentIDs(ids ...int) {
	if m.removedcomment_attachments == nil {
		m.removedcomment_attachments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comment_attachments, ids[i])
		m.removedcomment_attachments[ids[i]] = struct{}{}
	}
}

// RemovedCommentAttachments returns the removed IDs of the "comment_attachments" edge to the CommentAttachment entity.
func (m *CommentMutation) RemovedCommentAttachmentsIDs() (ids []int) {
	for id := range m.removedcomment_attachments {
		ids = append(ids, id)
	}
	return
}

// CommentAttachmentsIDs returns the "comment_attachments" edge IDs in the mutation.
func (m *CommentMutation) CommentAttachmentsIDs() (ids []int) {
	for id := range m.comment_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetCommentAttachments resets all changes to the "comment_attachments" edge.
func (m *CommentMutation) ResetCommentAttachments() {
	m.comment_attachments = nil
	m.clearedcomment_attachments = false
	m.removedcomment_attachments = nil
}

// AddLikedUserIDs adds the "liked_users" edge to the User entity by ids.
func (m *CommentMutation) AddLikedUserIDs(ids ...int) {
	if m.liked_users == nil {
		m.liked_users = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_users[ids[i]] = struct{}{}
	}
}

// ClearLikedUsers clears the "liked_users" edge to the User entity.
func (m *CommentMutation) ClearLikedUsers() {
	m.clearedliked_users = true
}

// LikedUsersCleared reports if the "liked_users" edge to the User entity was cleared.
func (m *CommentMutation) LikedUsersCleared() bool {
	return m.clearedliked_users
}

// RemoveLikedUserIDs removes the "liked_users" edge to the User entity by IDs.
func (m *CommentMutation) RemoveLikedUserIDs(ids ...int) {
	if m.removedliked_users == nil {
		m.removedliked_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_users, ids[i])
		m.removedliked_users[ids[i]] = struct{}{}
	}
}

// RemovedLikedUsers returns the removed IDs of the "liked_users" edge to the User entity.
func (m *CommentMutation) RemovedLikedUsersIDs() (ids []int) {
	for id := range m.removedliked_users {
		ids = append(ids, id)
	}
	return
}

// LikedUsersIDs returns the "liked_users" edge IDs in the mutation.
func (m *CommentMutation) LikedUsersIDs() (ids []int) {
	for id := range m.liked_users {
		ids = append(ids, id)
	}
	return
}

// ResetLikedUsers resets all changes to the "liked_users" edge.
func (m *CommentMutation) ResetLikedUsers() {
	m.liked_users = nil
	m.clearedliked_users = false
	m.removedliked_users = nil
}

// AddSubscribedUserIDs adds the "subscribed_users" edge to the User entity by ids.
func (m *CommentMutation) AddSubscribedUserIDs(ids ...int) {
	if m.subscribed_users == nil {
		m.subscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_users[ids[i]] = struct{}{}
	}
}

// ClearSubscribedUsers clears the "subscribed_users" edge to the User entity.
func (m *CommentMutation) ClearSubscribedUsers() {
	m.clearedsubscribed_users = true
}

// SubscribedUsersCleared reports if the "subscribed_users" edge to the User entity was cleared.
func (m *CommentMutation) SubscribedUsersCleared() bool {
	return m.clearedsubscribed_users
}

// RemoveSubscribedUserIDs removes the "subscribed_users" edge to the User entity by IDs.
func (m *CommentMutation) RemoveSubscribedUserIDs(ids ...int) {
	if m.removedsubscribed_users == nil {
		m.removedsubscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_users, ids[i])
		m.removedsubscribed_users[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedUsers returns the removed IDs of the "subscribed_users" edge to the User entity.
func (m *CommentMutation) RemovedSubscribedUsersIDs() (ids []int) {
	for id := range m.removedsubscribed_users {
		ids = append(ids, id)
	}
	return
}

// SubscribedUsersIDs returns the "subscribed_users" edge IDs in the mutation.
func (m *CommentMutation) SubscribedUsersIDs() (ids []int) {
	for id := range m.subscribed_users {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedUsers resets all changes to the "subscribed_users" edge.
func (m *CommentMutation) ResetSubscribedUsers() {
	m.subscribed_users = nil
	m.clearedsubscribed_users = false
	m.removedsubscribed_users = nil
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.thread != nil {
		fields = append(fields, comment.FieldThreadId)
	}
	if m.parent_comment != nil {
		fields = append(fields, comment.FieldParentCommentId)
	}
	if m.author != nil {
		fields = append(fields, comment.FieldUserId)
	}
	if m.guestName != nil {
		fields = append(fields, comment.FieldGuestName)
	}
	if m.message != nil {
		fields = append(fields, comment.FieldMessage)
	}
	if m.ip_address != nil {
		fields = append(fields, comment.FieldIPAddress)
	}
	if m.status != nil {
		fields = append(fields, comment.FieldStatus)
	}
	if m.createdAt != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldThreadId:
		return m.ThreadId()
	case comment.FieldParentCommentId:
		return m.ParentCommentId()
	case comment.FieldUserId:
		return m.UserId()
	case comment.FieldGuestName:
		return m.GuestName()
	case comment.FieldMessage:
		return m.Message()
	case comment.FieldIPAddress:
		return m.IPAddress()
	case comment.FieldStatus:
		return m.Status()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldThreadId:
		return m.OldThreadId(ctx)
	case comment.FieldParentCommentId:
		return m.OldParentCommentId(ctx)
	case comment.FieldUserId:
		return m.OldUserId(ctx)
	case comment.FieldGuestName:
		return m.OldGuestName(ctx)
	case comment.FieldMessage:
		return m.OldMessage(ctx)
	case comment.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case comment.FieldStatus:
		return m.OldStatus(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldThreadId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadId(v)
		return nil
	case comment.FieldParentCommentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentCommentId(v)
		return nil
	case comment.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case comment.FieldGuestName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuestName(v)
		return nil
	case comment.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case comment.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case comment.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, comment.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldParentCommentId) {
		fields = append(fields, comment.FieldParentCommentId)
	}
	if m.FieldCleared(comment.FieldUserId) {
		fields = append(fields, comment.FieldUserId)
	}
	if m.FieldCleared(comment.FieldGuestName) {
		fields = append(fields, comment.FieldGuestName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldParentCommentId:
		m.ClearParentCommentId()
		return nil
	case comment.FieldUserId:
		m.ClearUserId()
		return nil
	case comment.FieldGuestName:
		m.ClearGuestName()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldThreadId:
		m.ResetThreadId()
		return nil
	case comment.FieldParentCommentId:
		m.ResetParentCommentId()
		return nil
	case comment.FieldUserId:
		m.ResetUserId()
		return nil
	case comment.FieldGuestName:
		m.ResetGuestName()
		return nil
	case comment.FieldMessage:
		m.ResetMessage()
		return nil
	case comment.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case comment.FieldStatus:
		m.ResetStatus()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.thread != nil {
		edges = append(edges, comment.EdgeThread)
	}
	if m.author != nil {
		edges = append(edges, comment.EdgeAuthor)
	}
	if m.parent_comment != nil {
		edges = append(edges, comment.EdgeParentComment)
	}
	if m.replies != nil {
		edges = append(edges, comment.EdgeReplies)
	}
	if m.comment_attachments != nil {
		edges = append(edges, comment.EdgeCommentAttachments)
	}
	if m.liked_users != nil {
		edges = append(edges, comment.EdgeLikedUsers)
	}
	if m.subscribed_users != nil {
		edges = append(edges, comment.EdgeSubscribedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeParentComment:
		if id := m.parent_comment; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeCommentAttachments:
		ids := make([]ent.Value, 0, len(m.comment_attachments))
		for id := range m.comment_attachments {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.liked_users))
		for id := range m.liked_users {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.subscribed_users))
		for id := range m.subscribed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedreplies != nil {
		edges = append(edges, comment.EdgeReplies)
	}
	if m.removedcomment_attachments != nil {
		edges = append(edges, comment.EdgeCommentAttachments)
	}
	if m.removedliked_users != nil {
		edges = append(edges, comment.EdgeLikedUsers)
	}
	if m.removedsubscribed_users != nil {
		edges = append(edges, comment.EdgeSubscribedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeCommentAttachments:
		ids := make([]ent.Value, 0, len(m.removedcomment_attachments))
		for id := range m.removedcomment_attachments {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.removedliked_users))
		for id := range m.removedliked_users {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_users))
		for id := range m.removedsubscribed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedthread {
		edges = append(edges, comment.EdgeThread)
	}
	if m.clearedauthor {
		edges = append(edges, comment.EdgeAuthor)
	}
	if m.clearedparent_comment {
		edges = append(edges, comment.EdgeParentComment)
	}
	if m.clearedreplies {
		edges = append(edges, comment.EdgeReplies)
	}
	if m.clearedcomment_attachments {
		edges = append(edges, comment.EdgeCommentAttachments)
	}
	if m.clearedliked_users {
		edges = append(edges, comment.EdgeLikedUsers)
	}
	if m.clearedsubscribed_users {
		edges = append(edges, comment.EdgeSubscribedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeThread:
		return m.clearedthread
	case comment.EdgeAuthor:
		return m.clearedauthor
	case comment.EdgeParentComment:
		return m.clearedparent_comment
	case comment.EdgeReplies:
		return m.clearedreplies
	case comment.EdgeCommentAttachments:
		return m.clearedcomment_attachments
	case comment.EdgeLikedUsers:
		return m.clearedliked_users
	case comment.EdgeSubscribedUsers:
		return m.clearedsubscribed_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeThread:
		m.ClearThread()
		return nil
	case comment.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case comment.EdgeParentComment:
		m.ClearParentComment()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeThread:
		m.ResetThread()
		return nil
	case comment.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case comment.EdgeParentComment:
		m.ResetParentComment()
		return nil
	case comment.EdgeReplies:
		m.ResetReplies()
		return nil
	case comment.EdgeCommentAttachments:
		m.ResetCommentAttachments()
		return nil
	case comment.EdgeLikedUsers:
		m.ResetLikedUsers()
		return nil
	case comment.EdgeSubscribedUsers:
		m.ResetSubscribedUsers()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// CommentAttachmentMutation represents an operation that mutates the CommentAttachment nodes in the graph.
type CommentAttachmentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	url            *string
	_order         *int
	add_order      *int
	_type          *commentattachment.Type
	clearedFields  map[string]struct{}
	comment        *int
	clearedcomment bool
	done           bool
	oldValue       func(context.Context) (*CommentAttachment, error)
	predicates     []predicate.CommentAttachment
}

var _ ent.Mutation = (*CommentAttachmentMutation)(nil)

// commentattachmentOption allows management of the mutation configuration using functional options.
type commentattachmentOption func(*CommentAttachmentMutation)

// newCommentAttachmentMutation creates new mutation for the CommentAttachment entity.
func newCommentAttachmentMutation(c config, op Op, opts ...commentattachmentOption) *CommentAttachmentMutation {
	m := &CommentAttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeCommentAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentAttachmentID sets the ID field of the mutation.
func withCommentAttachmentID(id int) commentattachmentOption {
	return func(m *CommentAttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *CommentAttachment
		)
		m.oldValue = func(ctx context.Context) (*CommentAttachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommentAttachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommentAttachment sets the old CommentAttachment of the mutation.
func withCommentAttachment(node *CommentAttachment) commentattachmentOption {
	return func(m *CommentAttachmentMutation) {
		m.oldValue = func(context.Context) (*CommentAttachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentAttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentAttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommentAttachment entities.
func (m *CommentAttachmentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentAttachmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentAttachmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommentAttachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCommentId sets the "commentId" field.
func (m *CommentAttachmentMutation) SetCommentId(i int) {
	m.comment = &i
}

// CommentId returns the value of the "commentId" field in the mutation.
func (m *CommentAttachmentMutation) CommentId() (r int, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentId returns the old "commentId" field's value of the CommentAttachment entity.
// If the CommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentAttachmentMutation) OldCommentId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentId: %w", err)
	}
	return oldValue.CommentId, nil
}

// ResetCommentId resets all changes to the "commentId" field.
func (m *CommentAttachmentMutation) ResetCommentId() {
	m.comment = nil
}

// SetURL sets the "url" field.
func (m *CommentAttachmentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *CommentAttachmentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the CommentAttachment entity.
// If the CommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentAttachmentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *CommentAttachmentMutation) ResetURL() {
	m.url = nil
}

// SetOrder sets the "order" field.
func (m *CommentAttachmentMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *CommentAttachmentMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the CommentAttachment entity.
// If the CommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentAttachmentMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *CommentAttachmentMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *CommentAttachmentMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *CommentAttachmentMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetType sets the "type" field.
func (m *CommentAttachmentMutation) SetType(c commentattachment.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CommentAttachmentMutation) GetType() (r commentattachment.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CommentAttachment entity.
// If the CommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentAttachmentMutation) OldType(ctx context.Context) (v commentattachment.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CommentAttachmentMutation) ResetType() {
	m._type = nil
}

// SetCommentID sets the "comment" edge to the Comment entity by id.
func (m *CommentAttachmentMutation) SetCommentID(id int) {
	m.comment = &id
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *CommentAttachmentMutation) ClearComment() {
	m.clearedcomment = true
	m.clearedFields[commentattachment.FieldCommentId] = struct{}{}
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *CommentAttachmentMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentID returns the "comment" edge ID in the mutation.
func (m *CommentAttachmentMutation) CommentID() (id int, exists bool) {
	if m.comment != nil {
		return *m.comment, true
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *CommentAttachmentMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *CommentAttachmentMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the CommentAttachmentMutation builder.
func (m *CommentAttachmentMutation) Where(ps ...predicate.CommentAttachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentAttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentAttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommentAttachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentAttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentAttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommentAttachment).
func (m *CommentAttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentAttachmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.comment != nil {
		fields = append(fields, commentattachment.FieldCommentId)
	}
	if m.url != nil {
		fields = append(fields, commentattachment.FieldURL)
	}
	if m._order != nil {
		fields = append(fields, commentattachment.FieldOrder)
	}
	if m._type != nil {
		fields = append(fields, commentattachment.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentAttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commentattachment.FieldCommentId:
		return m.CommentId()
	case commentattachment.FieldURL:
		return m.URL()
	case commentattachment.FieldOrder:
		return m.Order()
	case commentattachment.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentAttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commentattachment.FieldCommentId:
		return m.OldCommentId(ctx)
	case commentattachment.FieldURL:
		return m.OldURL(ctx)
	case commentattachment.FieldOrder:
		return m.OldOrder(ctx)
	case commentattachment.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown CommentAttachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentAttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commentattachment.FieldCommentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentId(v)
		return nil
	case commentattachment.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case commentattachment.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case commentattachment.FieldType:
		v, ok := value.(commentattachment.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown CommentAttachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentAttachmentMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, commentattachment.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentAttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commentattachment.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentAttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commentattachment.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown CommentAttachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentAttachmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentAttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentAttachmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CommentAttachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentAttachmentMutation) ResetField(name string) error {
	switch name {
	case commentattachment.FieldCommentId:
		m.ResetCommentId()
		return nil
	case commentattachment.FieldURL:
		m.ResetURL()
		return nil
	case commentattachment.FieldOrder:
		m.ResetOrder()
		return nil
	case commentattachment.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown CommentAttachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentAttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.comment != nil {
		edges = append(edges, commentattachment.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentAttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commentattachment.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentAttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentAttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentAttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcomment {
		edges = append(edges, commentattachment.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentAttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case commentattachment.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentAttachmentMutation) ClearEdge(name string) error {
	switch name {
	case commentattachment.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown CommentAttachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentAttachmentMutation) ResetEdge(name string) error {
	switch name {
	case commentattachment.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown CommentAttachment edge %s", name)
}

// ThreadMutation represents an operation that mutates the Thread nodes in the graph.
type ThreadMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	title                   *string
	description             *string
	thumbnailUrl            *string
	isAutoGenerated         *bool
	isNotifyOnComment       *bool
	ip_address              *string
	status                  *int
	addstatus               *int
	createdAt               *time.Time
	updatedAt               *time.Time
	clearedFields           map[string]struct{}
	board                   *int
	clearedboard            bool
	owner                   *int
	clearedowner            bool
	comments                map[int]struct{}
	removedcomments         map[int]struct{}
	clearedcomments         bool
	tags                    map[int]struct{}
	removedtags             map[int]struct{}
	clearedtags             bool
	liked_users             map[int]struct{}
	removedliked_users      map[int]struct{}
	clearedliked_users      bool
	subscribed_users        map[int]struct{}
	removedsubscribed_users map[int]struct{}
	clearedsubscribed_users bool
	done                    bool
	oldValue                func(context.Context) (*Thread, error)
	predicates              []predicate.Thread
}

var _ ent.Mutation = (*ThreadMutation)(nil)

// threadOption allows management of the mutation configuration using functional options.
type threadOption func(*ThreadMutation)

// newThreadMutation creates new mutation for the Thread entity.
func newThreadMutation(c config, op Op, opts ...threadOption) *ThreadMutation {
	m := &ThreadMutation{
		config:        c,
		op:            op,
		typ:           TypeThread,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadID sets the ID field of the mutation.
func withThreadID(id int) threadOption {
	return func(m *ThreadMutation) {
		var (
			err   error
			once  sync.Once
			value *Thread
		)
		m.oldValue = func(ctx context.Context) (*Thread, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Thread.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThread sets the old Thread of the mutation.
func withThread(node *Thread) threadOption {
	return func(m *ThreadMutation) {
		m.oldValue = func(context.Context) (*Thread, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Thread entities.
func (m *ThreadMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Thread.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBoardId sets the "boardId" field.
func (m *ThreadMutation) SetBoardId(i int) {
	m.board = &i
}

// BoardId returns the value of the "boardId" field in the mutation.
func (m *ThreadMutation) BoardId() (r int, exists bool) {
	v := m.board
	if v == nil {
		return
	}
	return *v, true
}

// OldBoardId returns the old "boardId" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldBoardId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoardId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoardId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoardId: %w", err)
	}
	return oldValue.BoardId, nil
}

// ResetBoardId resets all changes to the "boardId" field.
func (m *ThreadMutation) ResetBoardId() {
	m.board = nil
}

// SetUserId sets the "userId" field.
func (m *ThreadMutation) SetUserId(i int) {
	m.owner = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *ThreadMutation) UserId() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldUserId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *ThreadMutation) ResetUserId() {
	m.owner = nil
}

// SetTitle sets the "title" field.
func (m *ThreadMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ThreadMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ThreadMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ThreadMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ThreadMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ThreadMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[thread.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ThreadMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[thread.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ThreadMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, thread.FieldDescription)
}

// SetThumbnailUrl sets the "thumbnailUrl" field.
func (m *ThreadMutation) SetThumbnailUrl(s string) {
	m.thumbnailUrl = &s
}

// ThumbnailUrl returns the value of the "thumbnailUrl" field in the mutation.
func (m *ThreadMutation) ThumbnailUrl() (r string, exists bool) {
	v := m.thumbnailUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailUrl returns the old "thumbnailUrl" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldThumbnailUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailUrl: %w", err)
	}
	return oldValue.ThumbnailUrl, nil
}

// ClearThumbnailUrl clears the value of the "thumbnailUrl" field.
func (m *ThreadMutation) ClearThumbnailUrl() {
	m.thumbnailUrl = nil
	m.clearedFields[thread.FieldThumbnailUrl] = struct{}{}
}

// ThumbnailUrlCleared returns if the "thumbnailUrl" field was cleared in this mutation.
func (m *ThreadMutation) ThumbnailUrlCleared() bool {
	_, ok := m.clearedFields[thread.FieldThumbnailUrl]
	return ok
}

// ResetThumbnailUrl resets all changes to the "thumbnailUrl" field.
func (m *ThreadMutation) ResetThumbnailUrl() {
	m.thumbnailUrl = nil
	delete(m.clearedFields, thread.FieldThumbnailUrl)
}

// SetIsAutoGenerated sets the "isAutoGenerated" field.
func (m *ThreadMutation) SetIsAutoGenerated(b bool) {
	m.isAutoGenerated = &b
}

// IsAutoGenerated returns the value of the "isAutoGenerated" field in the mutation.
func (m *ThreadMutation) IsAutoGenerated() (r bool, exists bool) {
	v := m.isAutoGenerated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAutoGenerated returns the old "isAutoGenerated" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldIsAutoGenerated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAutoGenerated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAutoGenerated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAutoGenerated: %w", err)
	}
	return oldValue.IsAutoGenerated, nil
}

// ResetIsAutoGenerated resets all changes to the "isAutoGenerated" field.
func (m *ThreadMutation) ResetIsAutoGenerated() {
	m.isAutoGenerated = nil
}

// SetIsNotifyOnComment sets the "isNotifyOnComment" field.
func (m *ThreadMutation) SetIsNotifyOnComment(b bool) {
	m.isNotifyOnComment = &b
}

// IsNotifyOnComment returns the value of the "isNotifyOnComment" field in the mutation.
func (m *ThreadMutation) IsNotifyOnComment() (r bool, exists bool) {
	v := m.isNotifyOnComment
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNotifyOnComment returns the old "isNotifyOnComment" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldIsNotifyOnComment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNotifyOnComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNotifyOnComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNotifyOnComment: %w", err)
	}
	return oldValue.IsNotifyOnComment, nil
}

// ResetIsNotifyOnComment resets all changes to the "isNotifyOnComment" field.
func (m *ThreadMutation) ResetIsNotifyOnComment() {
	m.isNotifyOnComment = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *ThreadMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *ThreadMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *ThreadMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetStatus sets the "status" field.
func (m *ThreadMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ThreadMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ThreadMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ThreadMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ThreadMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *ThreadMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ThreadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ThreadMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ThreadMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ThreadMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ThreadMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetBoardID sets the "board" edge to the Board entity by id.
func (m *ThreadMutation) SetBoardID(id int) {
	m.board = &id
}

// ClearBoard clears the "board" edge to the Board entity.
func (m *ThreadMutation) ClearBoard() {
	m.clearedboard = true
	m.clearedFields[thread.FieldBoardId] = struct{}{}
}

// BoardCleared reports if the "board" edge to the Board entity was cleared.
func (m *ThreadMutation) BoardCleared() bool {
	return m.clearedboard
}

// BoardID returns the "board" edge ID in the mutation.
func (m *ThreadMutation) BoardID() (id int, exists bool) {
	if m.board != nil {
		return *m.board, true
	}
	return
}

// BoardIDs returns the "board" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BoardID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) BoardIDs() (ids []int) {
	if id := m.board; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBoard resets all changes to the "board" edge.
func (m *ThreadMutation) ResetBoard() {
	m.board = nil
	m.clearedboard = false
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *ThreadMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ThreadMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[thread.FieldUserId] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ThreadMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ThreadMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ThreadMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *ThreadMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *ThreadMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *ThreadMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *ThreadMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *ThreadMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *ThreadMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *ThreadMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddTagIDs adds the "tags" edge to the ThreadTag entity by ids.
func (m *ThreadMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the ThreadTag entity.
func (m *ThreadMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the ThreadTag entity was cleared.
func (m *ThreadMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the ThreadTag entity by IDs.
func (m *ThreadMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the ThreadTag entity.
func (m *ThreadMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ThreadMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ThreadMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddLikedUserIDs adds the "liked_users" edge to the User entity by ids.
func (m *ThreadMutation) AddLikedUserIDs(ids ...int) {
	if m.liked_users == nil {
		m.liked_users = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_users[ids[i]] = struct{}{}
	}
}

// ClearLikedUsers clears the "liked_users" edge to the User entity.
func (m *ThreadMutation) ClearLikedUsers() {
	m.clearedliked_users = true
}

// LikedUsersCleared reports if the "liked_users" edge to the User entity was cleared.
func (m *ThreadMutation) LikedUsersCleared() bool {
	return m.clearedliked_users
}

// RemoveLikedUserIDs removes the "liked_users" edge to the User entity by IDs.
func (m *ThreadMutation) RemoveLikedUserIDs(ids ...int) {
	if m.removedliked_users == nil {
		m.removedliked_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_users, ids[i])
		m.removedliked_users[ids[i]] = struct{}{}
	}
}

// RemovedLikedUsers returns the removed IDs of the "liked_users" edge to the User entity.
func (m *ThreadMutation) RemovedLikedUsersIDs() (ids []int) {
	for id := range m.removedliked_users {
		ids = append(ids, id)
	}
	return
}

// LikedUsersIDs returns the "liked_users" edge IDs in the mutation.
func (m *ThreadMutation) LikedUsersIDs() (ids []int) {
	for id := range m.liked_users {
		ids = append(ids, id)
	}
	return
}

// ResetLikedUsers resets all changes to the "liked_users" edge.
func (m *ThreadMutation) ResetLikedUsers() {
	m.liked_users = nil
	m.clearedliked_users = false
	m.removedliked_users = nil
}

// AddSubscribedUserIDs adds the "subscribed_users" edge to the User entity by ids.
func (m *ThreadMutation) AddSubscribedUserIDs(ids ...int) {
	if m.subscribed_users == nil {
		m.subscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_users[ids[i]] = struct{}{}
	}
}

// ClearSubscribedUsers clears the "subscribed_users" edge to the User entity.
func (m *ThreadMutation) ClearSubscribedUsers() {
	m.clearedsubscribed_users = true
}

// SubscribedUsersCleared reports if the "subscribed_users" edge to the User entity was cleared.
func (m *ThreadMutation) SubscribedUsersCleared() bool {
	return m.clearedsubscribed_users
}

// RemoveSubscribedUserIDs removes the "subscribed_users" edge to the User entity by IDs.
func (m *ThreadMutation) RemoveSubscribedUserIDs(ids ...int) {
	if m.removedsubscribed_users == nil {
		m.removedsubscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_users, ids[i])
		m.removedsubscribed_users[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedUsers returns the removed IDs of the "subscribed_users" edge to the User entity.
func (m *ThreadMutation) RemovedSubscribedUsersIDs() (ids []int) {
	for id := range m.removedsubscribed_users {
		ids = append(ids, id)
	}
	return
}

// SubscribedUsersIDs returns the "subscribed_users" edge IDs in the mutation.
func (m *ThreadMutation) SubscribedUsersIDs() (ids []int) {
	for id := range m.subscribed_users {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedUsers resets all changes to the "subscribed_users" edge.
func (m *ThreadMutation) ResetSubscribedUsers() {
	m.subscribed_users = nil
	m.clearedsubscribed_users = false
	m.removedsubscribed_users = nil
}

// Where appends a list predicates to the ThreadMutation builder.
func (m *ThreadMutation) Where(ps ...predicate.Thread) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Thread, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Thread).
func (m *ThreadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.board != nil {
		fields = append(fields, thread.FieldBoardId)
	}
	if m.owner != nil {
		fields = append(fields, thread.FieldUserId)
	}
	if m.title != nil {
		fields = append(fields, thread.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, thread.FieldDescription)
	}
	if m.thumbnailUrl != nil {
		fields = append(fields, thread.FieldThumbnailUrl)
	}
	if m.isAutoGenerated != nil {
		fields = append(fields, thread.FieldIsAutoGenerated)
	}
	if m.isNotifyOnComment != nil {
		fields = append(fields, thread.FieldIsNotifyOnComment)
	}
	if m.ip_address != nil {
		fields = append(fields, thread.FieldIPAddress)
	}
	if m.status != nil {
		fields = append(fields, thread.FieldStatus)
	}
	if m.createdAt != nil {
		fields = append(fields, thread.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, thread.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldBoardId:
		return m.BoardId()
	case thread.FieldUserId:
		return m.UserId()
	case thread.FieldTitle:
		return m.Title()
	case thread.FieldDescription:
		return m.Description()
	case thread.FieldThumbnailUrl:
		return m.ThumbnailUrl()
	case thread.FieldIsAutoGenerated:
		return m.IsAutoGenerated()
	case thread.FieldIsNotifyOnComment:
		return m.IsNotifyOnComment()
	case thread.FieldIPAddress:
		return m.IPAddress()
	case thread.FieldStatus:
		return m.Status()
	case thread.FieldCreatedAt:
		return m.CreatedAt()
	case thread.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case thread.FieldBoardId:
		return m.OldBoardId(ctx)
	case thread.FieldUserId:
		return m.OldUserId(ctx)
	case thread.FieldTitle:
		return m.OldTitle(ctx)
	case thread.FieldDescription:
		return m.OldDescription(ctx)
	case thread.FieldThumbnailUrl:
		return m.OldThumbnailUrl(ctx)
	case thread.FieldIsAutoGenerated:
		return m.OldIsAutoGenerated(ctx)
	case thread.FieldIsNotifyOnComment:
		return m.OldIsNotifyOnComment(ctx)
	case thread.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case thread.FieldStatus:
		return m.OldStatus(ctx)
	case thread.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case thread.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Thread field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case thread.FieldBoardId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoardId(v)
		return nil
	case thread.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case thread.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case thread.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case thread.FieldThumbnailUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailUrl(v)
		return nil
	case thread.FieldIsAutoGenerated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAutoGenerated(v)
		return nil
	case thread.FieldIsNotifyOnComment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNotifyOnComment(v)
		return nil
	case thread.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case thread.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case thread.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case thread.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, thread.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case thread.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Thread numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(thread.FieldDescription) {
		fields = append(fields, thread.FieldDescription)
	}
	if m.FieldCleared(thread.FieldThumbnailUrl) {
		fields = append(fields, thread.FieldThumbnailUrl)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadMutation) ClearField(name string) error {
	switch name {
	case thread.FieldDescription:
		m.ClearDescription()
		return nil
	case thread.FieldThumbnailUrl:
		m.ClearThumbnailUrl()
		return nil
	}
	return fmt.Errorf("unknown Thread nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadMutation) ResetField(name string) error {
	switch name {
	case thread.FieldBoardId:
		m.ResetBoardId()
		return nil
	case thread.FieldUserId:
		m.ResetUserId()
		return nil
	case thread.FieldTitle:
		m.ResetTitle()
		return nil
	case thread.FieldDescription:
		m.ResetDescription()
		return nil
	case thread.FieldThumbnailUrl:
		m.ResetThumbnailUrl()
		return nil
	case thread.FieldIsAutoGenerated:
		m.ResetIsAutoGenerated()
		return nil
	case thread.FieldIsNotifyOnComment:
		m.ResetIsNotifyOnComment()
		return nil
	case thread.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case thread.FieldStatus:
		m.ResetStatus()
		return nil
	case thread.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case thread.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.board != nil {
		edges = append(edges, thread.EdgeBoard)
	}
	if m.owner != nil {
		edges = append(edges, thread.EdgeOwner)
	}
	if m.comments != nil {
		edges = append(edges, thread.EdgeComments)
	}
	if m.tags != nil {
		edges = append(edges, thread.EdgeTags)
	}
	if m.liked_users != nil {
		edges = append(edges, thread.EdgeLikedUsers)
	}
	if m.subscribed_users != nil {
		edges = append(edges, thread.EdgeSubscribedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeBoard:
		if id := m.board; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.liked_users))
		for id := range m.liked_users {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.subscribed_users))
		for id := range m.subscribed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcomments != nil {
		edges = append(edges, thread.EdgeComments)
	}
	if m.removedtags != nil {
		edges = append(edges, thread.EdgeTags)
	}
	if m.removedliked_users != nil {
		edges = append(edges, thread.EdgeLikedUsers)
	}
	if m.removedsubscribed_users != nil {
		edges = append(edges, thread.EdgeSubscribedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.removedliked_users))
		for id := range m.removedliked_users {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_users))
		for id := range m.removedsubscribed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedboard {
		edges = append(edges, thread.EdgeBoard)
	}
	if m.clearedowner {
		edges = append(edges, thread.EdgeOwner)
	}
	if m.clearedcomments {
		edges = append(edges, thread.EdgeComments)
	}
	if m.clearedtags {
		edges = append(edges, thread.EdgeTags)
	}
	if m.clearedliked_users {
		edges = append(edges, thread.EdgeLikedUsers)
	}
	if m.clearedsubscribed_users {
		edges = append(edges, thread.EdgeSubscribedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadMutation) EdgeCleared(name string) bool {
	switch name {
	case thread.EdgeBoard:
		return m.clearedboard
	case thread.EdgeOwner:
		return m.clearedowner
	case thread.EdgeComments:
		return m.clearedcomments
	case thread.EdgeTags:
		return m.clearedtags
	case thread.EdgeLikedUsers:
		return m.clearedliked_users
	case thread.EdgeSubscribedUsers:
		return m.clearedsubscribed_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadMutation) ClearEdge(name string) error {
	switch name {
	case thread.EdgeBoard:
		m.ClearBoard()
		return nil
	case thread.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Thread unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadMutation) ResetEdge(name string) error {
	switch name {
	case thread.EdgeBoard:
		m.ResetBoard()
		return nil
	case thread.EdgeOwner:
		m.ResetOwner()
		return nil
	case thread.EdgeComments:
		m.ResetComments()
		return nil
	case thread.EdgeTags:
		m.ResetTags()
		return nil
	case thread.EdgeLikedUsers:
		m.ResetLikedUsers()
		return nil
	case thread.EdgeSubscribedUsers:
		m.ResetSubscribedUsers()
		return nil
	}
	return fmt.Errorf("unknown Thread edge %s", name)
}

// ThreadTagMutation represents an operation that mutates the ThreadTag nodes in the graph.
type ThreadTagMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	createdAt      *time.Time
	clearedFields  map[string]struct{}
	threads        map[int]struct{}
	removedthreads map[int]struct{}
	clearedthreads bool
	done           bool
	oldValue       func(context.Context) (*ThreadTag, error)
	predicates     []predicate.ThreadTag
}

var _ ent.Mutation = (*ThreadTagMutation)(nil)

// threadtagOption allows management of the mutation configuration using functional options.
type threadtagOption func(*ThreadTagMutation)

// newThreadTagMutation creates new mutation for the ThreadTag entity.
func newThreadTagMutation(c config, op Op, opts ...threadtagOption) *ThreadTagMutation {
	m := &ThreadTagMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadTagID sets the ID field of the mutation.
func withThreadTagID(id int) threadtagOption {
	return func(m *ThreadTagMutation) {
		var (
			err   error
			once  sync.Once
			value *ThreadTag
		)
		m.oldValue = func(ctx context.Context) (*ThreadTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ThreadTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThreadTag sets the old ThreadTag of the mutation.
func withThreadTag(node *ThreadTag) threadtagOption {
	return func(m *ThreadTagMutation) {
		m.oldValue = func(context.Context) (*ThreadTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ThreadTag entities.
func (m *ThreadTagMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadTagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadTagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ThreadTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ThreadTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ThreadTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ThreadTag entity.
// If the ThreadTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ThreadTagMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *ThreadTagMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ThreadTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the ThreadTag entity.
// If the ThreadTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ThreadTagMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *ThreadTagMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *ThreadTagMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *ThreadTagMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *ThreadTagMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *ThreadTagMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *ThreadTagMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *ThreadTagMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// Where appends a list predicates to the ThreadTagMutation builder.
func (m *ThreadTagMutation) Where(ps ...predicate.ThreadTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadTag).
func (m *ThreadTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, threadtag.FieldName)
	}
	if m.createdAt != nil {
		fields = append(fields, threadtag.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threadtag.FieldName:
		return m.Name()
	case threadtag.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case threadtag.FieldName:
		return m.OldName(ctx)
	case threadtag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ThreadTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threadtag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case threadtag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ThreadTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ThreadTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadTagMutation) ResetField(name string) error {
	switch name {
	case threadtag.FieldName:
		m.ResetName()
		return nil
	case threadtag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ThreadTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.threads != nil {
		edges = append(edges, threadtag.EdgeThreads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case threadtag.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedthreads != nil {
		edges = append(edges, threadtag.EdgeThreads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case threadtag.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedthreads {
		edges = append(edges, threadtag.EdgeThreads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadTagMutation) EdgeCleared(name string) bool {
	switch name {
	case threadtag.EdgeThreads:
		return m.clearedthreads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ThreadTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadTagMutation) ResetEdge(name string) error {
	switch name {
	case threadtag.EdgeThreads:
		m.ResetThreads()
		return nil
	}
	return fmt.Errorf("unknown ThreadTag edge %s", name)
}

// ThreadTaggingMutation represents an operation that mutates the ThreadTagging nodes in the graph.
type ThreadTaggingMutation struct {
	config
	op            Op
	typ           string
	clearedFields map[string]struct{}
	thread        *int
	clearedthread bool
	tag           *int
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*ThreadTagging, error)
	predicates    []predicate.ThreadTagging
}

var _ ent.Mutation = (*ThreadTaggingMutation)(nil)

// threadtaggingOption allows management of the mutation configuration using functional options.
type threadtaggingOption func(*ThreadTaggingMutation)

// newThreadTaggingMutation creates new mutation for the ThreadTagging entity.
func newThreadTaggingMutation(c config, op Op, opts ...threadtaggingOption) *ThreadTaggingMutation {
	m := &ThreadTaggingMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadTagging,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadTaggingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadTaggingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetThreadId sets the "threadId" field.
func (m *ThreadTaggingMutation) SetThreadId(i int) {
	m.thread = &i
}

// ThreadId returns the value of the "threadId" field in the mutation.
func (m *ThreadTaggingMutation) ThreadId() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// ResetThreadId resets all changes to the "threadId" field.
func (m *ThreadTaggingMutation) ResetThreadId() {
	m.thread = nil
}

// SetTagId sets the "tagId" field.
func (m *ThreadTaggingMutation) SetTagId(i int) {
	m.tag = &i
}

// TagId returns the value of the "tagId" field in the mutation.
func (m *ThreadTaggingMutation) TagId() (r int, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// ResetTagId resets all changes to the "tagId" field.
func (m *ThreadTaggingMutation) ResetTagId() {
	m.tag = nil
}

// SetThreadID sets the "thread" edge to the Thread entity by id.
func (m *ThreadTaggingMutation) SetThreadID(id int) {
	m.thread = &id
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *ThreadTaggingMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[threadtagging.FieldThreadId] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *ThreadTaggingMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadID returns the "thread" edge ID in the mutation.
func (m *ThreadTaggingMutation) ThreadID() (id int, exists bool) {
	if m.thread != nil {
		return *m.thread, true
	}
	return
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *ThreadTaggingMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *ThreadTaggingMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// SetTagID sets the "tag" edge to the ThreadTag entity by id.
func (m *ThreadTaggingMutation) SetTagID(id int) {
	m.tag = &id
}

// ClearTag clears the "tag" edge to the ThreadTag entity.
func (m *ThreadTaggingMutation) ClearTag() {
	m.clearedtag = true
	m.clearedFields[threadtagging.FieldTagId] = struct{}{}
}

// TagCleared reports if the "tag" edge to the ThreadTag entity was cleared.
func (m *ThreadTaggingMutation) TagCleared() bool {
	return m.clearedtag
}

// TagID returns the "tag" edge ID in the mutation.
func (m *ThreadTaggingMutation) TagID() (id int, exists bool) {
	if m.tag != nil {
		return *m.tag, true
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *ThreadTaggingMutation) TagIDs() (ids []int) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *ThreadTaggingMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// Where appends a list predicates to the ThreadTaggingMutation builder.
func (m *ThreadTaggingMutation) Where(ps ...predicate.ThreadTagging) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadTaggingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadTaggingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadTagging, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadTaggingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadTaggingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadTagging).
func (m *ThreadTaggingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadTaggingMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.thread != nil {
		fields = append(fields, threadtagging.FieldThreadId)
	}
	if m.tag != nil {
		fields = append(fields, threadtagging.FieldTagId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadTaggingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threadtagging.FieldThreadId:
		return m.ThreadId()
	case threadtagging.FieldTagId:
		return m.TagId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadTaggingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema ThreadTagging does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadTaggingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threadtagging.FieldThreadId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadId(v)
		return nil
	case threadtagging.FieldTagId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagId(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadTagging field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadTaggingMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadTaggingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadTaggingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ThreadTagging numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadTaggingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadTaggingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadTaggingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ThreadTagging nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadTaggingMutation) ResetField(name string) error {
	switch name {
	case threadtagging.FieldThreadId:
		m.ResetThreadId()
		return nil
	case threadtagging.FieldTagId:
		m.ResetTagId()
		return nil
	}
	return fmt.Errorf("unknown ThreadTagging field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadTaggingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.thread != nil {
		edges = append(edges, threadtagging.EdgeThread)
	}
	if m.tag != nil {
		edges = append(edges, threadtagging.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadTaggingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case threadtagging.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	case threadtagging.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadTaggingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadTaggingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadTaggingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedthread {
		edges = append(edges, threadtagging.EdgeThread)
	}
	if m.clearedtag {
		edges = append(edges, threadtagging.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadTaggingMutation) EdgeCleared(name string) bool {
	switch name {
	case threadtagging.EdgeThread:
		return m.clearedthread
	case threadtagging.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadTaggingMutation) ClearEdge(name string) error {
	switch name {
	case threadtagging.EdgeThread:
		m.ClearThread()
		return nil
	case threadtagging.EdgeTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown ThreadTagging unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadTaggingMutation) ResetEdge(name string) error {
	switch name {
	case threadtagging.EdgeThread:
		m.ResetThread()
		return nil
	case threadtagging.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown ThreadTagging edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	name                       *string
	email                      *string
	password                   *string
	displayName                *string
	avatarUrl                  *string
	status                     *int
	addstatus                  *int
	role                       *int
	addrole                    *int
	createdAt                  *time.Time
	updatedAt                  *time.Time
	clearedFields              map[string]struct{}
	boards                     map[int]struct{}
	removedboards              map[int]struct{}
	clearedboards              bool
	threads                    map[int]struct{}
	removedthreads             map[int]struct{}
	clearedthreads             bool
	comments                   map[int]struct{}
	removedcomments            map[int]struct{}
	clearedcomments            bool
	liked_boards               map[int]struct{}
	removedliked_boards        map[int]struct{}
	clearedliked_boards        bool
	liked_threads              map[int]struct{}
	removedliked_threads       map[int]struct{}
	clearedliked_threads       bool
	liked_comments             map[int]struct{}
	removedliked_comments      map[int]struct{}
	clearedliked_comments      bool
	subscribed_boards          map[int]struct{}
	removedsubscribed_boards   map[int]struct{}
	clearedsubscribed_boards   bool
	subscribed_threads         map[int]struct{}
	removedsubscribed_threads  map[int]struct{}
	clearedsubscribed_threads  bool
	subscribed_comments        map[int]struct{}
	removedsubscribed_comments map[int]struct{}
	clearedsubscribed_comments bool
	done                       bool
	oldValue                   func(context.Context) (*User, error)
	predicates                 []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetDisplayName sets the "displayName" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.displayName = &s
}

// DisplayName returns the value of the "displayName" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.displayName
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "displayName" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "displayName" field.
func (m *UserMutation) ClearDisplayName() {
	m.displayName = nil
	m.clearedFields[user.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "displayName" field was cleared in this mutation.
func (m *UserMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[user.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "displayName" field.
func (m *UserMutation) ResetDisplayName() {
	m.displayName = nil
	delete(m.clearedFields, user.FieldDisplayName)
}

// SetAvatarUrl sets the "avatarUrl" field.
func (m *UserMutation) SetAvatarUrl(s string) {
	m.avatarUrl = &s
}

// AvatarUrl returns the value of the "avatarUrl" field in the mutation.
func (m *UserMutation) AvatarUrl() (r string, exists bool) {
	v := m.avatarUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarUrl returns the old "avatarUrl" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarUrl: %w", err)
	}
	return oldValue.AvatarUrl, nil
}

// ClearAvatarUrl clears the value of the "avatarUrl" field.
func (m *UserMutation) ClearAvatarUrl() {
	m.avatarUrl = nil
	m.clearedFields[user.FieldAvatarUrl] = struct{}{}
}

// AvatarUrlCleared returns if the "avatarUrl" field was cleared in this mutation.
func (m *UserMutation) AvatarUrlCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarUrl]
	return ok
}

// ResetAvatarUrl resets all changes to the "avatarUrl" field.
func (m *UserMutation) ResetAvatarUrl() {
	m.avatarUrl = nil
	delete(m.clearedFields, user.FieldAvatarUrl)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(i int) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *UserMutation) AddRole(i int) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *UserMutation) AddedRole() (r int, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// AddBoardIDs adds the "boards" edge to the Board entity by ids.
func (m *UserMutation) AddBoardIDs(ids ...int) {
	if m.boards == nil {
		m.boards = make(map[int]struct{})
	}
	for i := range ids {
		m.boards[ids[i]] = struct{}{}
	}
}

// ClearBoards clears the "boards" edge to the Board entity.
func (m *UserMutation) ClearBoards() {
	m.clearedboards = true
}

// BoardsCleared reports if the "boards" edge to the Board entity was cleared.
func (m *UserMutation) BoardsCleared() bool {
	return m.clearedboards
}

// RemoveBoardIDs removes the "boards" edge to the Board entity by IDs.
func (m *UserMutation) RemoveBoardIDs(ids ...int) {
	if m.removedboards == nil {
		m.removedboards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.boards, ids[i])
		m.removedboards[ids[i]] = struct{}{}
	}
}

// RemovedBoards returns the removed IDs of the "boards" edge to the Board entity.
func (m *UserMutation) RemovedBoardsIDs() (ids []int) {
	for id := range m.removedboards {
		ids = append(ids, id)
	}
	return
}

// BoardsIDs returns the "boards" edge IDs in the mutation.
func (m *UserMutation) BoardsIDs() (ids []int) {
	for id := range m.boards {
		ids = append(ids, id)
	}
	return
}

// ResetBoards resets all changes to the "boards" edge.
func (m *UserMutation) ResetBoards() {
	m.boards = nil
	m.clearedboards = false
	m.removedboards = nil
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *UserMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *UserMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *UserMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *UserMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *UserMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *UserMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *UserMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *UserMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *UserMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *UserMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *UserMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *UserMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddLikedBoardIDs adds the "liked_boards" edge to the Board entity by ids.
func (m *UserMutation) AddLikedBoardIDs(ids ...int) {
	if m.liked_boards == nil {
		m.liked_boards = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_boards[ids[i]] = struct{}{}
	}
}

// ClearLikedBoards clears the "liked_boards" edge to the Board entity.
func (m *UserMutation) ClearLikedBoards() {
	m.clearedliked_boards = true
}

// LikedBoardsCleared reports if the "liked_boards" edge to the Board entity was cleared.
func (m *UserMutation) LikedBoardsCleared() bool {
	return m.clearedliked_boards
}

// RemoveLikedBoardIDs removes the "liked_boards" edge to the Board entity by IDs.
func (m *UserMutation) RemoveLikedBoardIDs(ids ...int) {
	if m.removedliked_boards == nil {
		m.removedliked_boards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_boards, ids[i])
		m.removedliked_boards[ids[i]] = struct{}{}
	}
}

// RemovedLikedBoards returns the removed IDs of the "liked_boards" edge to the Board entity.
func (m *UserMutation) RemovedLikedBoardsIDs() (ids []int) {
	for id := range m.removedliked_boards {
		ids = append(ids, id)
	}
	return
}

// LikedBoardsIDs returns the "liked_boards" edge IDs in the mutation.
func (m *UserMutation) LikedBoardsIDs() (ids []int) {
	for id := range m.liked_boards {
		ids = append(ids, id)
	}
	return
}

// ResetLikedBoards resets all changes to the "liked_boards" edge.
func (m *UserMutation) ResetLikedBoards() {
	m.liked_boards = nil
	m.clearedliked_boards = false
	m.removedliked_boards = nil
}

// AddLikedThreadIDs adds the "liked_threads" edge to the Thread entity by ids.
func (m *UserMutation) AddLikedThreadIDs(ids ...int) {
	if m.liked_threads == nil {
		m.liked_threads = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_threads[ids[i]] = struct{}{}
	}
}

// ClearLikedThreads clears the "liked_threads" edge to the Thread entity.
func (m *UserMutation) ClearLikedThreads() {
	m.clearedliked_threads = true
}

// LikedThreadsCleared reports if the "liked_threads" edge to the Thread entity was cleared.
func (m *UserMutation) LikedThreadsCleared() bool {
	return m.clearedliked_threads
}

// RemoveLikedThreadIDs removes the "liked_threads" edge to the Thread entity by IDs.
func (m *UserMutation) RemoveLikedThreadIDs(ids ...int) {
	if m.removedliked_threads == nil {
		m.removedliked_threads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_threads, ids[i])
		m.removedliked_threads[ids[i]] = struct{}{}
	}
}

// RemovedLikedThreads returns the removed IDs of the "liked_threads" edge to the Thread entity.
func (m *UserMutation) RemovedLikedThreadsIDs() (ids []int) {
	for id := range m.removedliked_threads {
		ids = append(ids, id)
	}
	return
}

// LikedThreadsIDs returns the "liked_threads" edge IDs in the mutation.
func (m *UserMutation) LikedThreadsIDs() (ids []int) {
	for id := range m.liked_threads {
		ids = append(ids, id)
	}
	return
}

// ResetLikedThreads resets all changes to the "liked_threads" edge.
func (m *UserMutation) ResetLikedThreads() {
	m.liked_threads = nil
	m.clearedliked_threads = false
	m.removedliked_threads = nil
}

// AddLikedCommentIDs adds the "liked_comments" edge to the Comment entity by ids.
func (m *UserMutation) AddLikedCommentIDs(ids ...int) {
	if m.liked_comments == nil {
		m.liked_comments = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_comments[ids[i]] = struct{}{}
	}
}

// ClearLikedComments clears the "liked_comments" edge to the Comment entity.
func (m *UserMutation) ClearLikedComments() {
	m.clearedliked_comments = true
}

// LikedCommentsCleared reports if the "liked_comments" edge to the Comment entity was cleared.
func (m *UserMutation) LikedCommentsCleared() bool {
	return m.clearedliked_comments
}

// RemoveLikedCommentIDs removes the "liked_comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveLikedCommentIDs(ids ...int) {
	if m.removedliked_comments == nil {
		m.removedliked_comments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_comments, ids[i])
		m.removedliked_comments[ids[i]] = struct{}{}
	}
}

// RemovedLikedComments returns the removed IDs of the "liked_comments" edge to the Comment entity.
func (m *UserMutation) RemovedLikedCommentsIDs() (ids []int) {
	for id := range m.removedliked_comments {
		ids = append(ids, id)
	}
	return
}

// LikedCommentsIDs returns the "liked_comments" edge IDs in the mutation.
func (m *UserMutation) LikedCommentsIDs() (ids []int) {
	for id := range m.liked_comments {
		ids = append(ids, id)
	}
	return
}

// ResetLikedComments resets all changes to the "liked_comments" edge.
func (m *UserMutation) ResetLikedComments() {
	m.liked_comments = nil
	m.clearedliked_comments = false
	m.removedliked_comments = nil
}

// AddSubscribedBoardIDs adds the "subscribed_boards" edge to the Board entity by ids.
func (m *UserMutation) AddSubscribedBoardIDs(ids ...int) {
	if m.subscribed_boards == nil {
		m.subscribed_boards = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_boards[ids[i]] = struct{}{}
	}
}

// ClearSubscribedBoards clears the "subscribed_boards" edge to the Board entity.
func (m *UserMutation) ClearSubscribedBoards() {
	m.clearedsubscribed_boards = true
}

// SubscribedBoardsCleared reports if the "subscribed_boards" edge to the Board entity was cleared.
func (m *UserMutation) SubscribedBoardsCleared() bool {
	return m.clearedsubscribed_boards
}

// RemoveSubscribedBoardIDs removes the "subscribed_boards" edge to the Board entity by IDs.
func (m *UserMutation) RemoveSubscribedBoardIDs(ids ...int) {
	if m.removedsubscribed_boards == nil {
		m.removedsubscribed_boards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_boards, ids[i])
		m.removedsubscribed_boards[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedBoards returns the removed IDs of the "subscribed_boards" edge to the Board entity.
func (m *UserMutation) RemovedSubscribedBoardsIDs() (ids []int) {
	for id := range m.removedsubscribed_boards {
		ids = append(ids, id)
	}
	return
}

// SubscribedBoardsIDs returns the "subscribed_boards" edge IDs in the mutation.
func (m *UserMutation) SubscribedBoardsIDs() (ids []int) {
	for id := range m.subscribed_boards {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedBoards resets all changes to the "subscribed_boards" edge.
func (m *UserMutation) ResetSubscribedBoards() {
	m.subscribed_boards = nil
	m.clearedsubscribed_boards = false
	m.removedsubscribed_boards = nil
}

// AddSubscribedThreadIDs adds the "subscribed_threads" edge to the Thread entity by ids.
func (m *UserMutation) AddSubscribedThreadIDs(ids ...int) {
	if m.subscribed_threads == nil {
		m.subscribed_threads = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_threads[ids[i]] = struct{}{}
	}
}

// ClearSubscribedThreads clears the "subscribed_threads" edge to the Thread entity.
func (m *UserMutation) ClearSubscribedThreads() {
	m.clearedsubscribed_threads = true
}

// SubscribedThreadsCleared reports if the "subscribed_threads" edge to the Thread entity was cleared.
func (m *UserMutation) SubscribedThreadsCleared() bool {
	return m.clearedsubscribed_threads
}

// RemoveSubscribedThreadIDs removes the "subscribed_threads" edge to the Thread entity by IDs.
func (m *UserMutation) RemoveSubscribedThreadIDs(ids ...int) {
	if m.removedsubscribed_threads == nil {
		m.removedsubscribed_threads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_threads, ids[i])
		m.removedsubscribed_threads[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedThreads returns the removed IDs of the "subscribed_threads" edge to the Thread entity.
func (m *UserMutation) RemovedSubscribedThreadsIDs() (ids []int) {
	for id := range m.removedsubscribed_threads {
		ids = append(ids, id)
	}
	return
}

// SubscribedThreadsIDs returns the "subscribed_threads" edge IDs in the mutation.
func (m *UserMutation) SubscribedThreadsIDs() (ids []int) {
	for id := range m.subscribed_threads {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedThreads resets all changes to the "subscribed_threads" edge.
func (m *UserMutation) ResetSubscribedThreads() {
	m.subscribed_threads = nil
	m.clearedsubscribed_threads = false
	m.removedsubscribed_threads = nil
}

// AddSubscribedCommentIDs adds the "subscribed_comments" edge to the Comment entity by ids.
func (m *UserMutation) AddSubscribedCommentIDs(ids ...int) {
	if m.subscribed_comments == nil {
		m.subscribed_comments = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_comments[ids[i]] = struct{}{}
	}
}

// ClearSubscribedComments clears the "subscribed_comments" edge to the Comment entity.
func (m *UserMutation) ClearSubscribedComments() {
	m.clearedsubscribed_comments = true
}

// SubscribedCommentsCleared reports if the "subscribed_comments" edge to the Comment entity was cleared.
func (m *UserMutation) SubscribedCommentsCleared() bool {
	return m.clearedsubscribed_comments
}

// RemoveSubscribedCommentIDs removes the "subscribed_comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveSubscribedCommentIDs(ids ...int) {
	if m.removedsubscribed_comments == nil {
		m.removedsubscribed_comments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_comments, ids[i])
		m.removedsubscribed_comments[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedComments returns the removed IDs of the "subscribed_comments" edge to the Comment entity.
func (m *UserMutation) RemovedSubscribedCommentsIDs() (ids []int) {
	for id := range m.removedsubscribed_comments {
		ids = append(ids, id)
	}
	return
}

// SubscribedCommentsIDs returns the "subscribed_comments" edge IDs in the mutation.
func (m *UserMutation) SubscribedCommentsIDs() (ids []int) {
	for id := range m.subscribed_comments {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedComments resets all changes to the "subscribed_comments" edge.
func (m *UserMutation) ResetSubscribedComments() {
	m.subscribed_comments = nil
	m.clearedsubscribed_comments = false
	m.removedsubscribed_comments = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.displayName != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.avatarUrl != nil {
		fields = append(fields, user.FieldAvatarUrl)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldAvatarUrl:
		return m.AvatarUrl()
	case user.FieldStatus:
		return m.Status()
	case user.FieldRole:
		return m.Role()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldAvatarUrl:
		return m.OldAvatarUrl(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldAvatarUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarUrl(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.addrole != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.AddedStatus()
	case user.FieldRole:
		return m.AddedRole()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case user.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDisplayName) {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.FieldCleared(user.FieldAvatarUrl) {
		fields = append(fields, user.FieldAvatarUrl)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case user.FieldAvatarUrl:
		m.ClearAvatarUrl()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldAvatarUrl:
		m.ResetAvatarUrl()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.boards != nil {
		edges = append(edges, user.EdgeBoards)
	}
	if m.threads != nil {
		edges = append(edges, user.EdgeThreads)
	}
	if m.comments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.liked_boards != nil {
		edges = append(edges, user.EdgeLikedBoards)
	}
	if m.liked_threads != nil {
		edges = append(edges, user.EdgeLikedThreads)
	}
	if m.liked_comments != nil {
		edges = append(edges, user.EdgeLikedComments)
	}
	if m.subscribed_boards != nil {
		edges = append(edges, user.EdgeSubscribedBoards)
	}
	if m.subscribed_threads != nil {
		edges = append(edges, user.EdgeSubscribedThreads)
	}
	if m.subscribed_comments != nil {
		edges = append(edges, user.EdgeSubscribedComments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBoards:
		ids := make([]ent.Value, 0, len(m.boards))
		for id := range m.boards {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedBoards:
		ids := make([]ent.Value, 0, len(m.liked_boards))
		for id := range m.liked_boards {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedThreads:
		ids := make([]ent.Value, 0, len(m.liked_threads))
		for id := range m.liked_threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedComments:
		ids := make([]ent.Value, 0, len(m.liked_comments))
		for id := range m.liked_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedBoards:
		ids := make([]ent.Value, 0, len(m.subscribed_boards))
		for id := range m.subscribed_boards {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedThreads:
		ids := make([]ent.Value, 0, len(m.subscribed_threads))
		for id := range m.subscribed_threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedComments:
		ids := make([]ent.Value, 0, len(m.subscribed_comments))
		for id := range m.subscribed_comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedboards != nil {
		edges = append(edges, user.EdgeBoards)
	}
	if m.removedthreads != nil {
		edges = append(edges, user.EdgeThreads)
	}
	if m.removedcomments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.removedliked_boards != nil {
		edges = append(edges, user.EdgeLikedBoards)
	}
	if m.removedliked_threads != nil {
		edges = append(edges, user.EdgeLikedThreads)
	}
	if m.removedliked_comments != nil {
		edges = append(edges, user.EdgeLikedComments)
	}
	if m.removedsubscribed_boards != nil {
		edges = append(edges, user.EdgeSubscribedBoards)
	}
	if m.removedsubscribed_threads != nil {
		edges = append(edges, user.EdgeSubscribedThreads)
	}
	if m.removedsubscribed_comments != nil {
		edges = append(edges, user.EdgeSubscribedComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBoards:
		ids := make([]ent.Value, 0, len(m.removedboards))
		for id := range m.removedboards {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedBoards:
		ids := make([]ent.Value, 0, len(m.removedliked_boards))
		for id := range m.removedliked_boards {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedThreads:
		ids := make([]ent.Value, 0, len(m.removedliked_threads))
		for id := range m.removedliked_threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedComments:
		ids := make([]ent.Value, 0, len(m.removedliked_comments))
		for id := range m.removedliked_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedBoards:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_boards))
		for id := range m.removedsubscribed_boards {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedThreads:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_threads))
		for id := range m.removedsubscribed_threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedComments:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_comments))
		for id := range m.removedsubscribed_comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedboards {
		edges = append(edges, user.EdgeBoards)
	}
	if m.clearedthreads {
		edges = append(edges, user.EdgeThreads)
	}
	if m.clearedcomments {
		edges = append(edges, user.EdgeComments)
	}
	if m.clearedliked_boards {
		edges = append(edges, user.EdgeLikedBoards)
	}
	if m.clearedliked_threads {
		edges = append(edges, user.EdgeLikedThreads)
	}
	if m.clearedliked_comments {
		edges = append(edges, user.EdgeLikedComments)
	}
	if m.clearedsubscribed_boards {
		edges = append(edges, user.EdgeSubscribedBoards)
	}
	if m.clearedsubscribed_threads {
		edges = append(edges, user.EdgeSubscribedThreads)
	}
	if m.clearedsubscribed_comments {
		edges = append(edges, user.EdgeSubscribedComments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBoards:
		return m.clearedboards
	case user.EdgeThreads:
		return m.clearedthreads
	case user.EdgeComments:
		return m.clearedcomments
	case user.EdgeLikedBoards:
		return m.clearedliked_boards
	case user.EdgeLikedThreads:
		return m.clearedliked_threads
	case user.EdgeLikedComments:
		return m.clearedliked_comments
	case user.EdgeSubscribedBoards:
		return m.clearedsubscribed_boards
	case user.EdgeSubscribedThreads:
		return m.clearedsubscribed_threads
	case user.EdgeSubscribedComments:
		return m.clearedsubscribed_comments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBoards:
		m.ResetBoards()
		return nil
	case user.EdgeThreads:
		m.ResetThreads()
		return nil
	case user.EdgeComments:
		m.ResetComments()
		return nil
	case user.EdgeLikedBoards:
		m.ResetLikedBoards()
		return nil
	case user.EdgeLikedThreads:
		m.ResetLikedThreads()
		return nil
	case user.EdgeLikedComments:
		m.ResetLikedComments()
		return nil
	case user.EdgeSubscribedBoards:
		m.ResetSubscribedBoards()
		return nil
	case user.EdgeSubscribedThreads:
		m.ResetSubscribedThreads()
		return nil
	case user.EdgeSubscribedComments:
		m.ResetSubscribedComments()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserBoardLikeMutation represents an operation that mutates the UserBoardLike nodes in the graph.
type UserBoardLikeMutation struct {
	config
	op            Op
	typ           string
	likedAt       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	board         *int
	clearedboard  bool
	done          bool
	oldValue      func(context.Context) (*UserBoardLike, error)
	predicates    []predicate.UserBoardLike
}

var _ ent.Mutation = (*UserBoardLikeMutation)(nil)

// userboardlikeOption allows management of the mutation configuration using functional options.
type userboardlikeOption func(*UserBoardLikeMutation)

// newUserBoardLikeMutation creates new mutation for the UserBoardLike entity.
func newUserBoardLikeMutation(c config, op Op, opts ...userboardlikeOption) *UserBoardLikeMutation {
	m := &UserBoardLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBoardLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBoardLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBoardLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserId sets the "userId" field.
func (m *UserBoardLikeMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserBoardLikeMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserBoardLikeMutation) ResetUserId() {
	m.user = nil
}

// SetBoardId sets the "boardId" field.
func (m *UserBoardLikeMutation) SetBoardId(i int) {
	m.board = &i
}

// BoardId returns the value of the "boardId" field in the mutation.
func (m *UserBoardLikeMutation) BoardId() (r int, exists bool) {
	v := m.board
	if v == nil {
		return
	}
	return *v, true
}

// ResetBoardId resets all changes to the "boardId" field.
func (m *UserBoardLikeMutation) ResetBoardId() {
	m.board = nil
}

// SetLikedAt sets the "likedAt" field.
func (m *UserBoardLikeMutation) SetLikedAt(t time.Time) {
	m.likedAt = &t
}

// LikedAt returns the value of the "likedAt" field in the mutation.
func (m *UserBoardLikeMutation) LikedAt() (r time.Time, exists bool) {
	v := m.likedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikedAt resets all changes to the "likedAt" field.
func (m *UserBoardLikeMutation) ResetLikedAt() {
	m.likedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserBoardLikeMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserBoardLikeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userboardlike.FieldUserId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserBoardLikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserBoardLikeMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserBoardLikeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserBoardLikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBoardID sets the "board" edge to the Board entity by id.
func (m *UserBoardLikeMutation) SetBoardID(id int) {
	m.board = &id
}

// ClearBoard clears the "board" edge to the Board entity.
func (m *UserBoardLikeMutation) ClearBoard() {
	m.clearedboard = true
	m.clearedFields[userboardlike.FieldBoardId] = struct{}{}
}

// BoardCleared reports if the "board" edge to the Board entity was cleared.
func (m *UserBoardLikeMutation) BoardCleared() bool {
	return m.clearedboard
}

// BoardID returns the "board" edge ID in the mutation.
func (m *UserBoardLikeMutation) BoardID() (id int, exists bool) {
	if m.board != nil {
		return *m.board, true
	}
	return
}

// BoardIDs returns the "board" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BoardID instead. It exists only for internal usage by the builders.
func (m *UserBoardLikeMutation) BoardIDs() (ids []int) {
	if id := m.board; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBoard resets all changes to the "board" edge.
func (m *UserBoardLikeMutation) ResetBoard() {
	m.board = nil
	m.clearedboard = false
}

// Where appends a list predicates to the UserBoardLikeMutation builder.
func (m *UserBoardLikeMutation) Where(ps ...predicate.UserBoardLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBoardLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBoardLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBoardLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBoardLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBoardLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBoardLike).
func (m *UserBoardLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBoardLikeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, userboardlike.FieldUserId)
	}
	if m.board != nil {
		fields = append(fields, userboardlike.FieldBoardId)
	}
	if m.likedAt != nil {
		fields = append(fields, userboardlike.FieldLikedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBoardLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userboardlike.FieldUserId:
		return m.UserId()
	case userboardlike.FieldBoardId:
		return m.BoardId()
	case userboardlike.FieldLikedAt:
		return m.LikedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBoardLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserBoardLike does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBoardLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userboardlike.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case userboardlike.FieldBoardId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoardId(v)
		return nil
	case userboardlike.FieldLikedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserBoardLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBoardLikeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBoardLikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBoardLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserBoardLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBoardLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBoardLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBoardLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserBoardLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBoardLikeMutation) ResetField(name string) error {
	switch name {
	case userboardlike.FieldUserId:
		m.ResetUserId()
		return nil
	case userboardlike.FieldBoardId:
		m.ResetBoardId()
		return nil
	case userboardlike.FieldLikedAt:
		m.ResetLikedAt()
		return nil
	}
	return fmt.Errorf("unknown UserBoardLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBoardLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userboardlike.EdgeUser)
	}
	if m.board != nil {
		edges = append(edges, userboardlike.EdgeBoard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBoardLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userboardlike.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userboardlike.EdgeBoard:
		if id := m.board; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBoardLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBoardLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBoardLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userboardlike.EdgeUser)
	}
	if m.clearedboard {
		edges = append(edges, userboardlike.EdgeBoard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBoardLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case userboardlike.EdgeUser:
		return m.cleareduser
	case userboardlike.EdgeBoard:
		return m.clearedboard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBoardLikeMutation) ClearEdge(name string) error {
	switch name {
	case userboardlike.EdgeUser:
		m.ClearUser()
		return nil
	case userboardlike.EdgeBoard:
		m.ClearBoard()
		return nil
	}
	return fmt.Errorf("unknown UserBoardLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBoardLikeMutation) ResetEdge(name string) error {
	switch name {
	case userboardlike.EdgeUser:
		m.ResetUser()
		return nil
	case userboardlike.EdgeBoard:
		m.ResetBoard()
		return nil
	}
	return fmt.Errorf("unknown UserBoardLike edge %s", name)
}

// UserBoardSubscriptionMutation represents an operation that mutates the UserBoardSubscription nodes in the graph.
type UserBoardSubscriptionMutation struct {
	config
	op            Op
	typ           string
	isNotified    *bool
	isChecked     *bool
	subscribedAt  *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	board         *int
	clearedboard  bool
	done          bool
	oldValue      func(context.Context) (*UserBoardSubscription, error)
	predicates    []predicate.UserBoardSubscription
}

var _ ent.Mutation = (*UserBoardSubscriptionMutation)(nil)

// userboardsubscriptionOption allows management of the mutation configuration using functional options.
type userboardsubscriptionOption func(*UserBoardSubscriptionMutation)

// newUserBoardSubscriptionMutation creates new mutation for the UserBoardSubscription entity.
func newUserBoardSubscriptionMutation(c config, op Op, opts ...userboardsubscriptionOption) *UserBoardSubscriptionMutation {
	m := &UserBoardSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBoardSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBoardSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBoardSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserId sets the "userId" field.
func (m *UserBoardSubscriptionMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserBoardSubscriptionMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserBoardSubscriptionMutation) ResetUserId() {
	m.user = nil
}

// SetBoardId sets the "boardId" field.
func (m *UserBoardSubscriptionMutation) SetBoardId(i int) {
	m.board = &i
}

// BoardId returns the value of the "boardId" field in the mutation.
func (m *UserBoardSubscriptionMutation) BoardId() (r int, exists bool) {
	v := m.board
	if v == nil {
		return
	}
	return *v, true
}

// ResetBoardId resets all changes to the "boardId" field.
func (m *UserBoardSubscriptionMutation) ResetBoardId() {
	m.board = nil
}

// SetIsNotified sets the "isNotified" field.
func (m *UserBoardSubscriptionMutation) SetIsNotified(b bool) {
	m.isNotified = &b
}

// IsNotified returns the value of the "isNotified" field in the mutation.
func (m *UserBoardSubscriptionMutation) IsNotified() (r bool, exists bool) {
	v := m.isNotified
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsNotified resets all changes to the "isNotified" field.
func (m *UserBoardSubscriptionMutation) ResetIsNotified() {
	m.isNotified = nil
}

// SetIsChecked sets the "isChecked" field.
func (m *UserBoardSubscriptionMutation) SetIsChecked(b bool) {
	m.isChecked = &b
}

// IsChecked returns the value of the "isChecked" field in the mutation.
func (m *UserBoardSubscriptionMutation) IsChecked() (r bool, exists bool) {
	v := m.isChecked
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsChecked resets all changes to the "isChecked" field.
func (m *UserBoardSubscriptionMutation) ResetIsChecked() {
	m.isChecked = nil
}

// SetSubscribedAt sets the "subscribedAt" field.
func (m *UserBoardSubscriptionMutation) SetSubscribedAt(t time.Time) {
	m.subscribedAt = &t
}

// SubscribedAt returns the value of the "subscribedAt" field in the mutation.
func (m *UserBoardSubscriptionMutation) SubscribedAt() (r time.Time, exists bool) {
	v := m.subscribedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubscribedAt resets all changes to the "subscribedAt" field.
func (m *UserBoardSubscriptionMutation) ResetSubscribedAt() {
	m.subscribedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserBoardSubscriptionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserBoardSubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userboardsubscription.FieldUserId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserBoardSubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserBoardSubscriptionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserBoardSubscriptionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserBoardSubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBoardID sets the "board" edge to the Board entity by id.
func (m *UserBoardSubscriptionMutation) SetBoardID(id int) {
	m.board = &id
}

// ClearBoard clears the "board" edge to the Board entity.
func (m *UserBoardSubscriptionMutation) ClearBoard() {
	m.clearedboard = true
	m.clearedFields[userboardsubscription.FieldBoardId] = struct{}{}
}

// BoardCleared reports if the "board" edge to the Board entity was cleared.
func (m *UserBoardSubscriptionMutation) BoardCleared() bool {
	return m.clearedboard
}

// BoardID returns the "board" edge ID in the mutation.
func (m *UserBoardSubscriptionMutation) BoardID() (id int, exists bool) {
	if m.board != nil {
		return *m.board, true
	}
	return
}

// BoardIDs returns the "board" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BoardID instead. It exists only for internal usage by the builders.
func (m *UserBoardSubscriptionMutation) BoardIDs() (ids []int) {
	if id := m.board; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBoard resets all changes to the "board" edge.
func (m *UserBoardSubscriptionMutation) ResetBoard() {
	m.board = nil
	m.clearedboard = false
}

// Where appends a list predicates to the UserBoardSubscriptionMutation builder.
func (m *UserBoardSubscriptionMutation) Where(ps ...predicate.UserBoardSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBoardSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBoardSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBoardSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBoardSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBoardSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBoardSubscription).
func (m *UserBoardSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBoardSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, userboardsubscription.FieldUserId)
	}
	if m.board != nil {
		fields = append(fields, userboardsubscription.FieldBoardId)
	}
	if m.isNotified != nil {
		fields = append(fields, userboardsubscription.FieldIsNotified)
	}
	if m.isChecked != nil {
		fields = append(fields, userboardsubscription.FieldIsChecked)
	}
	if m.subscribedAt != nil {
		fields = append(fields, userboardsubscription.FieldSubscribedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBoardSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userboardsubscription.FieldUserId:
		return m.UserId()
	case userboardsubscription.FieldBoardId:
		return m.BoardId()
	case userboardsubscription.FieldIsNotified:
		return m.IsNotified()
	case userboardsubscription.FieldIsChecked:
		return m.IsChecked()
	case userboardsubscription.FieldSubscribedAt:
		return m.SubscribedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBoardSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserBoardSubscription does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBoardSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userboardsubscription.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case userboardsubscription.FieldBoardId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoardId(v)
		return nil
	case userboardsubscription.FieldIsNotified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNotified(v)
		return nil
	case userboardsubscription.FieldIsChecked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsChecked(v)
		return nil
	case userboardsubscription.FieldSubscribedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserBoardSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBoardSubscriptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBoardSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBoardSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserBoardSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBoardSubscriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBoardSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBoardSubscriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserBoardSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBoardSubscriptionMutation) ResetField(name string) error {
	switch name {
	case userboardsubscription.FieldUserId:
		m.ResetUserId()
		return nil
	case userboardsubscription.FieldBoardId:
		m.ResetBoardId()
		return nil
	case userboardsubscription.FieldIsNotified:
		m.ResetIsNotified()
		return nil
	case userboardsubscription.FieldIsChecked:
		m.ResetIsChecked()
		return nil
	case userboardsubscription.FieldSubscribedAt:
		m.ResetSubscribedAt()
		return nil
	}
	return fmt.Errorf("unknown UserBoardSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBoardSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userboardsubscription.EdgeUser)
	}
	if m.board != nil {
		edges = append(edges, userboardsubscription.EdgeBoard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBoardSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userboardsubscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userboardsubscription.EdgeBoard:
		if id := m.board; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBoardSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBoardSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBoardSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userboardsubscription.EdgeUser)
	}
	if m.clearedboard {
		edges = append(edges, userboardsubscription.EdgeBoard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBoardSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case userboardsubscription.EdgeUser:
		return m.cleareduser
	case userboardsubscription.EdgeBoard:
		return m.clearedboard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBoardSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case userboardsubscription.EdgeUser:
		m.ClearUser()
		return nil
	case userboardsubscription.EdgeBoard:
		m.ClearBoard()
		return nil
	}
	return fmt.Errorf("unknown UserBoardSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBoardSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case userboardsubscription.EdgeUser:
		m.ResetUser()
		return nil
	case userboardsubscription.EdgeBoard:
		m.ResetBoard()
		return nil
	}
	return fmt.Errorf("unknown UserBoardSubscription edge %s", name)
}

// UserCommentLikeMutation represents an operation that mutates the UserCommentLike nodes in the graph.
type UserCommentLikeMutation struct {
	config
	op             Op
	typ            string
	likedAt        *time.Time
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	comment        *int
	clearedcomment bool
	done           bool
	oldValue       func(context.Context) (*UserCommentLike, error)
	predicates     []predicate.UserCommentLike
}

var _ ent.Mutation = (*UserCommentLikeMutation)(nil)

// usercommentlikeOption allows management of the mutation configuration using functional options.
type usercommentlikeOption func(*UserCommentLikeMutation)

// newUserCommentLikeMutation creates new mutation for the UserCommentLike entity.
func newUserCommentLikeMutation(c config, op Op, opts ...usercommentlikeOption) *UserCommentLikeMutation {
	m := &UserCommentLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCommentLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCommentLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCommentLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserId sets the "userId" field.
func (m *UserCommentLikeMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserCommentLikeMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserCommentLikeMutation) ResetUserId() {
	m.user = nil
}

// SetCommentId sets the "commentId" field.
func (m *UserCommentLikeMutation) SetCommentId(i int) {
	m.comment = &i
}

// CommentId returns the value of the "commentId" field in the mutation.
func (m *UserCommentLikeMutation) CommentId() (r int, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentId resets all changes to the "commentId" field.
func (m *UserCommentLikeMutation) ResetCommentId() {
	m.comment = nil
}

// SetLikedAt sets the "likedAt" field.
func (m *UserCommentLikeMutation) SetLikedAt(t time.Time) {
	m.likedAt = &t
}

// LikedAt returns the value of the "likedAt" field in the mutation.
func (m *UserCommentLikeMutation) LikedAt() (r time.Time, exists bool) {
	v := m.likedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikedAt resets all changes to the "likedAt" field.
func (m *UserCommentLikeMutation) ResetLikedAt() {
	m.likedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserCommentLikeMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserCommentLikeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usercommentlike.FieldUserId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserCommentLikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserCommentLikeMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserCommentLikeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserCommentLikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetCommentID sets the "comment" edge to the Comment entity by id.
func (m *UserCommentLikeMutation) SetCommentID(id int) {
	m.comment = &id
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *UserCommentLikeMutation) ClearComment() {
	m.clearedcomment = true
	m.clearedFields[usercommentlike.FieldCommentId] = struct{}{}
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *UserCommentLikeMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentID returns the "comment" edge ID in the mutation.
func (m *UserCommentLikeMutation) CommentID() (id int, exists bool) {
	if m.comment != nil {
		return *m.comment, true
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *UserCommentLikeMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *UserCommentLikeMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the UserCommentLikeMutation builder.
func (m *UserCommentLikeMutation) Where(ps ...predicate.UserCommentLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCommentLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCommentLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCommentLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCommentLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCommentLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCommentLike).
func (m *UserCommentLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCommentLikeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, usercommentlike.FieldUserId)
	}
	if m.comment != nil {
		fields = append(fields, usercommentlike.FieldCommentId)
	}
	if m.likedAt != nil {
		fields = append(fields, usercommentlike.FieldLikedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCommentLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercommentlike.FieldUserId:
		return m.UserId()
	case usercommentlike.FieldCommentId:
		return m.CommentId()
	case usercommentlike.FieldLikedAt:
		return m.LikedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCommentLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserCommentLike does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCommentLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercommentlike.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case usercommentlike.FieldCommentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentId(v)
		return nil
	case usercommentlike.FieldLikedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserCommentLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCommentLikeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCommentLikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCommentLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCommentLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCommentLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCommentLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCommentLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserCommentLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCommentLikeMutation) ResetField(name string) error {
	switch name {
	case usercommentlike.FieldUserId:
		m.ResetUserId()
		return nil
	case usercommentlike.FieldCommentId:
		m.ResetCommentId()
		return nil
	case usercommentlike.FieldLikedAt:
		m.ResetLikedAt()
		return nil
	}
	return fmt.Errorf("unknown UserCommentLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCommentLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usercommentlike.EdgeUser)
	}
	if m.comment != nil {
		edges = append(edges, usercommentlike.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCommentLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercommentlike.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usercommentlike.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCommentLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCommentLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCommentLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usercommentlike.EdgeUser)
	}
	if m.clearedcomment {
		edges = append(edges, usercommentlike.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCommentLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case usercommentlike.EdgeUser:
		return m.cleareduser
	case usercommentlike.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCommentLikeMutation) ClearEdge(name string) error {
	switch name {
	case usercommentlike.EdgeUser:
		m.ClearUser()
		return nil
	case usercommentlike.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown UserCommentLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCommentLikeMutation) ResetEdge(name string) error {
	switch name {
	case usercommentlike.EdgeUser:
		m.ResetUser()
		return nil
	case usercommentlike.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown UserCommentLike edge %s", name)
}

// UserCommentSubscriptionMutation represents an operation that mutates the UserCommentSubscription nodes in the graph.
type UserCommentSubscriptionMutation struct {
	config
	op             Op
	typ            string
	isNotified     *bool
	isChecked      *bool
	subscribedAt   *time.Time
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	comment        *int
	clearedcomment bool
	done           bool
	oldValue       func(context.Context) (*UserCommentSubscription, error)
	predicates     []predicate.UserCommentSubscription
}

var _ ent.Mutation = (*UserCommentSubscriptionMutation)(nil)

// usercommentsubscriptionOption allows management of the mutation configuration using functional options.
type usercommentsubscriptionOption func(*UserCommentSubscriptionMutation)

// newUserCommentSubscriptionMutation creates new mutation for the UserCommentSubscription entity.
func newUserCommentSubscriptionMutation(c config, op Op, opts ...usercommentsubscriptionOption) *UserCommentSubscriptionMutation {
	m := &UserCommentSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCommentSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCommentSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCommentSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserId sets the "userId" field.
func (m *UserCommentSubscriptionMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserCommentSubscriptionMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserCommentSubscriptionMutation) ResetUserId() {
	m.user = nil
}

// SetCommentId sets the "commentId" field.
func (m *UserCommentSubscriptionMutation) SetCommentId(i int) {
	m.comment = &i
}

// CommentId returns the value of the "commentId" field in the mutation.
func (m *UserCommentSubscriptionMutation) CommentId() (r int, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentId resets all changes to the "commentId" field.
func (m *UserCommentSubscriptionMutation) ResetCommentId() {
	m.comment = nil
}

// SetIsNotified sets the "isNotified" field.
func (m *UserCommentSubscriptionMutation) SetIsNotified(b bool) {
	m.isNotified = &b
}

// IsNotified returns the value of the "isNotified" field in the mutation.
func (m *UserCommentSubscriptionMutation) IsNotified() (r bool, exists bool) {
	v := m.isNotified
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsNotified resets all changes to the "isNotified" field.
func (m *UserCommentSubscriptionMutation) ResetIsNotified() {
	m.isNotified = nil
}

// SetIsChecked sets the "isChecked" field.
func (m *UserCommentSubscriptionMutation) SetIsChecked(b bool) {
	m.isChecked = &b
}

// IsChecked returns the value of the "isChecked" field in the mutation.
func (m *UserCommentSubscriptionMutation) IsChecked() (r bool, exists bool) {
	v := m.isChecked
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsChecked resets all changes to the "isChecked" field.
func (m *UserCommentSubscriptionMutation) ResetIsChecked() {
	m.isChecked = nil
}

// SetSubscribedAt sets the "subscribedAt" field.
func (m *UserCommentSubscriptionMutation) SetSubscribedAt(t time.Time) {
	m.subscribedAt = &t
}

// SubscribedAt returns the value of the "subscribedAt" field in the mutation.
func (m *UserCommentSubscriptionMutation) SubscribedAt() (r time.Time, exists bool) {
	v := m.subscribedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubscribedAt resets all changes to the "subscribedAt" field.
func (m *UserCommentSubscriptionMutation) ResetSubscribedAt() {
	m.subscribedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserCommentSubscriptionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserCommentSubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usercommentsubscription.FieldUserId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserCommentSubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserCommentSubscriptionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserCommentSubscriptionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserCommentSubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetCommentID sets the "comment" edge to the Comment entity by id.
func (m *UserCommentSubscriptionMutation) SetCommentID(id int) {
	m.comment = &id
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *UserCommentSubscriptionMutation) ClearComment() {
	m.clearedcomment = true
	m.clearedFields[usercommentsubscription.FieldCommentId] = struct{}{}
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *UserCommentSubscriptionMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentID returns the "comment" edge ID in the mutation.
func (m *UserCommentSubscriptionMutation) CommentID() (id int, exists bool) {
	if m.comment != nil {
		return *m.comment, true
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *UserCommentSubscriptionMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *UserCommentSubscriptionMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the UserCommentSubscriptionMutation builder.
func (m *UserCommentSubscriptionMutation) Where(ps ...predicate.UserCommentSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCommentSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCommentSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCommentSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCommentSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCommentSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCommentSubscription).
func (m *UserCommentSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCommentSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, usercommentsubscription.FieldUserId)
	}
	if m.comment != nil {
		fields = append(fields, usercommentsubscription.FieldCommentId)
	}
	if m.isNotified != nil {
		fields = append(fields, usercommentsubscription.FieldIsNotified)
	}
	if m.isChecked != nil {
		fields = append(fields, usercommentsubscription.FieldIsChecked)
	}
	if m.subscribedAt != nil {
		fields = append(fields, usercommentsubscription.FieldSubscribedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCommentSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercommentsubscription.FieldUserId:
		return m.UserId()
	case usercommentsubscription.FieldCommentId:
		return m.CommentId()
	case usercommentsubscription.FieldIsNotified:
		return m.IsNotified()
	case usercommentsubscription.FieldIsChecked:
		return m.IsChecked()
	case usercommentsubscription.FieldSubscribedAt:
		return m.SubscribedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCommentSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserCommentSubscription does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCommentSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercommentsubscription.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case usercommentsubscription.FieldCommentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentId(v)
		return nil
	case usercommentsubscription.FieldIsNotified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNotified(v)
		return nil
	case usercommentsubscription.FieldIsChecked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsChecked(v)
		return nil
	case usercommentsubscription.FieldSubscribedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserCommentSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCommentSubscriptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCommentSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCommentSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCommentSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCommentSubscriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCommentSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCommentSubscriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserCommentSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCommentSubscriptionMutation) ResetField(name string) error {
	switch name {
	case usercommentsubscription.FieldUserId:
		m.ResetUserId()
		return nil
	case usercommentsubscription.FieldCommentId:
		m.ResetCommentId()
		return nil
	case usercommentsubscription.FieldIsNotified:
		m.ResetIsNotified()
		return nil
	case usercommentsubscription.FieldIsChecked:
		m.ResetIsChecked()
		return nil
	case usercommentsubscription.FieldSubscribedAt:
		m.ResetSubscribedAt()
		return nil
	}
	return fmt.Errorf("unknown UserCommentSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCommentSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usercommentsubscription.EdgeUser)
	}
	if m.comment != nil {
		edges = append(edges, usercommentsubscription.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCommentSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercommentsubscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usercommentsubscription.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCommentSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCommentSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCommentSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usercommentsubscription.EdgeUser)
	}
	if m.clearedcomment {
		edges = append(edges, usercommentsubscription.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCommentSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case usercommentsubscription.EdgeUser:
		return m.cleareduser
	case usercommentsubscription.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCommentSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case usercommentsubscription.EdgeUser:
		m.ClearUser()
		return nil
	case usercommentsubscription.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown UserCommentSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCommentSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case usercommentsubscription.EdgeUser:
		m.ResetUser()
		return nil
	case usercommentsubscription.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown UserCommentSubscription edge %s", name)
}

// UserThreadLikeMutation represents an operation that mutates the UserThreadLike nodes in the graph.
type UserThreadLikeMutation struct {
	config
	op            Op
	typ           string
	likedAt       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	thread        *int
	clearedthread bool
	done          bool
	oldValue      func(context.Context) (*UserThreadLike, error)
	predicates    []predicate.UserThreadLike
}

var _ ent.Mutation = (*UserThreadLikeMutation)(nil)

// userthreadlikeOption allows management of the mutation configuration using functional options.
type userthreadlikeOption func(*UserThreadLikeMutation)

// newUserThreadLikeMutation creates new mutation for the UserThreadLike entity.
func newUserThreadLikeMutation(c config, op Op, opts ...userthreadlikeOption) *UserThreadLikeMutation {
	m := &UserThreadLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserThreadLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserThreadLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserThreadLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserId sets the "userId" field.
func (m *UserThreadLikeMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserThreadLikeMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserThreadLikeMutation) ResetUserId() {
	m.user = nil
}

// SetThreadId sets the "threadId" field.
func (m *UserThreadLikeMutation) SetThreadId(i int) {
	m.thread = &i
}

// ThreadId returns the value of the "threadId" field in the mutation.
func (m *UserThreadLikeMutation) ThreadId() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// ResetThreadId resets all changes to the "threadId" field.
func (m *UserThreadLikeMutation) ResetThreadId() {
	m.thread = nil
}

// SetLikedAt sets the "likedAt" field.
func (m *UserThreadLikeMutation) SetLikedAt(t time.Time) {
	m.likedAt = &t
}

// LikedAt returns the value of the "likedAt" field in the mutation.
func (m *UserThreadLikeMutation) LikedAt() (r time.Time, exists bool) {
	v := m.likedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikedAt resets all changes to the "likedAt" field.
func (m *UserThreadLikeMutation) ResetLikedAt() {
	m.likedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserThreadLikeMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserThreadLikeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userthreadlike.FieldUserId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserThreadLikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserThreadLikeMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserThreadLikeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserThreadLikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetThreadID sets the "thread" edge to the Thread entity by id.
func (m *UserThreadLikeMutation) SetThreadID(id int) {
	m.thread = &id
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *UserThreadLikeMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[userthreadlike.FieldThreadId] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *UserThreadLikeMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadID returns the "thread" edge ID in the mutation.
func (m *UserThreadLikeMutation) ThreadID() (id int, exists bool) {
	if m.thread != nil {
		return *m.thread, true
	}
	return
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *UserThreadLikeMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *UserThreadLikeMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// Where appends a list predicates to the UserThreadLikeMutation builder.
func (m *UserThreadLikeMutation) Where(ps ...predicate.UserThreadLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserThreadLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserThreadLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserThreadLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserThreadLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserThreadLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserThreadLike).
func (m *UserThreadLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserThreadLikeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, userthreadlike.FieldUserId)
	}
	if m.thread != nil {
		fields = append(fields, userthreadlike.FieldThreadId)
	}
	if m.likedAt != nil {
		fields = append(fields, userthreadlike.FieldLikedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserThreadLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userthreadlike.FieldUserId:
		return m.UserId()
	case userthreadlike.FieldThreadId:
		return m.ThreadId()
	case userthreadlike.FieldLikedAt:
		return m.LikedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserThreadLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserThreadLike does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserThreadLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userthreadlike.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case userthreadlike.FieldThreadId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadId(v)
		return nil
	case userthreadlike.FieldLikedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserThreadLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserThreadLikeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserThreadLikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserThreadLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserThreadLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserThreadLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserThreadLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserThreadLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserThreadLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserThreadLikeMutation) ResetField(name string) error {
	switch name {
	case userthreadlike.FieldUserId:
		m.ResetUserId()
		return nil
	case userthreadlike.FieldThreadId:
		m.ResetThreadId()
		return nil
	case userthreadlike.FieldLikedAt:
		m.ResetLikedAt()
		return nil
	}
	return fmt.Errorf("unknown UserThreadLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserThreadLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userthreadlike.EdgeUser)
	}
	if m.thread != nil {
		edges = append(edges, userthreadlike.EdgeThread)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserThreadLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userthreadlike.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userthreadlike.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserThreadLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserThreadLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserThreadLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userthreadlike.EdgeUser)
	}
	if m.clearedthread {
		edges = append(edges, userthreadlike.EdgeThread)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserThreadLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case userthreadlike.EdgeUser:
		return m.cleareduser
	case userthreadlike.EdgeThread:
		return m.clearedthread
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserThreadLikeMutation) ClearEdge(name string) error {
	switch name {
	case userthreadlike.EdgeUser:
		m.ClearUser()
		return nil
	case userthreadlike.EdgeThread:
		m.ClearThread()
		return nil
	}
	return fmt.Errorf("unknown UserThreadLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserThreadLikeMutation) ResetEdge(name string) error {
	switch name {
	case userthreadlike.EdgeUser:
		m.ResetUser()
		return nil
	case userthreadlike.EdgeThread:
		m.ResetThread()
		return nil
	}
	return fmt.Errorf("unknown UserThreadLike edge %s", name)
}

// UserThreadSubscriptionMutation represents an operation that mutates the UserThreadSubscription nodes in the graph.
type UserThreadSubscriptionMutation struct {
	config
	op            Op
	typ           string
	isNotified    *bool
	isChecked     *bool
	subscribedAt  *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	thread        *int
	clearedthread bool
	done          bool
	oldValue      func(context.Context) (*UserThreadSubscription, error)
	predicates    []predicate.UserThreadSubscription
}

var _ ent.Mutation = (*UserThreadSubscriptionMutation)(nil)

// userthreadsubscriptionOption allows management of the mutation configuration using functional options.
type userthreadsubscriptionOption func(*UserThreadSubscriptionMutation)

// newUserThreadSubscriptionMutation creates new mutation for the UserThreadSubscription entity.
func newUserThreadSubscriptionMutation(c config, op Op, opts ...userthreadsubscriptionOption) *UserThreadSubscriptionMutation {
	m := &UserThreadSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserThreadSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserThreadSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserThreadSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserId sets the "userId" field.
func (m *UserThreadSubscriptionMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserThreadSubscriptionMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserThreadSubscriptionMutation) ResetUserId() {
	m.user = nil
}

// SetThreadId sets the "threadId" field.
func (m *UserThreadSubscriptionMutation) SetThreadId(i int) {
	m.thread = &i
}

// ThreadId returns the value of the "threadId" field in the mutation.
func (m *UserThreadSubscriptionMutation) ThreadId() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// ResetThreadId resets all changes to the "threadId" field.
func (m *UserThreadSubscriptionMutation) ResetThreadId() {
	m.thread = nil
}

// SetIsNotified sets the "isNotified" field.
func (m *UserThreadSubscriptionMutation) SetIsNotified(b bool) {
	m.isNotified = &b
}

// IsNotified returns the value of the "isNotified" field in the mutation.
func (m *UserThreadSubscriptionMutation) IsNotified() (r bool, exists bool) {
	v := m.isNotified
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsNotified resets all changes to the "isNotified" field.
func (m *UserThreadSubscriptionMutation) ResetIsNotified() {
	m.isNotified = nil
}

// SetIsChecked sets the "isChecked" field.
func (m *UserThreadSubscriptionMutation) SetIsChecked(b bool) {
	m.isChecked = &b
}

// IsChecked returns the value of the "isChecked" field in the mutation.
func (m *UserThreadSubscriptionMutation) IsChecked() (r bool, exists bool) {
	v := m.isChecked
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsChecked resets all changes to the "isChecked" field.
func (m *UserThreadSubscriptionMutation) ResetIsChecked() {
	m.isChecked = nil
}

// SetSubscribedAt sets the "subscribedAt" field.
func (m *UserThreadSubscriptionMutation) SetSubscribedAt(t time.Time) {
	m.subscribedAt = &t
}

// SubscribedAt returns the value of the "subscribedAt" field in the mutation.
func (m *UserThreadSubscriptionMutation) SubscribedAt() (r time.Time, exists bool) {
	v := m.subscribedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubscribedAt resets all changes to the "subscribedAt" field.
func (m *UserThreadSubscriptionMutation) ResetSubscribedAt() {
	m.subscribedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserThreadSubscriptionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserThreadSubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userthreadsubscription.FieldUserId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserThreadSubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserThreadSubscriptionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserThreadSubscriptionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserThreadSubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetThreadID sets the "thread" edge to the Thread entity by id.
func (m *UserThreadSubscriptionMutation) SetThreadID(id int) {
	m.thread = &id
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *UserThreadSubscriptionMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[userthreadsubscription.FieldThreadId] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *UserThreadSubscriptionMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadID returns the "thread" edge ID in the mutation.
func (m *UserThreadSubscriptionMutation) ThreadID() (id int, exists bool) {
	if m.thread != nil {
		return *m.thread, true
	}
	return
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *UserThreadSubscriptionMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *UserThreadSubscriptionMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// Where appends a list predicates to the UserThreadSubscriptionMutation builder.
func (m *UserThreadSubscriptionMutation) Where(ps ...predicate.UserThreadSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserThreadSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserThreadSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserThreadSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserThreadSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserThreadSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserThreadSubscription).
func (m *UserThreadSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserThreadSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, userthreadsubscription.FieldUserId)
	}
	if m.thread != nil {
		fields = append(fields, userthreadsubscription.FieldThreadId)
	}
	if m.isNotified != nil {
		fields = append(fields, userthreadsubscription.FieldIsNotified)
	}
	if m.isChecked != nil {
		fields = append(fields, userthreadsubscription.FieldIsChecked)
	}
	if m.subscribedAt != nil {
		fields = append(fields, userthreadsubscription.FieldSubscribedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserThreadSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userthreadsubscription.FieldUserId:
		return m.UserId()
	case userthreadsubscription.FieldThreadId:
		return m.ThreadId()
	case userthreadsubscription.FieldIsNotified:
		return m.IsNotified()
	case userthreadsubscription.FieldIsChecked:
		return m.IsChecked()
	case userthreadsubscription.FieldSubscribedAt:
		return m.SubscribedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserThreadSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserThreadSubscription does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserThreadSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userthreadsubscription.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case userthreadsubscription.FieldThreadId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadId(v)
		return nil
	case userthreadsubscription.FieldIsNotified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNotified(v)
		return nil
	case userthreadsubscription.FieldIsChecked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsChecked(v)
		return nil
	case userthreadsubscription.FieldSubscribedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserThreadSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserThreadSubscriptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserThreadSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserThreadSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserThreadSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserThreadSubscriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserThreadSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserThreadSubscriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserThreadSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserThreadSubscriptionMutation) ResetField(name string) error {
	switch name {
	case userthreadsubscription.FieldUserId:
		m.ResetUserId()
		return nil
	case userthreadsubscription.FieldThreadId:
		m.ResetThreadId()
		return nil
	case userthreadsubscription.FieldIsNotified:
		m.ResetIsNotified()
		return nil
	case userthreadsubscription.FieldIsChecked:
		m.ResetIsChecked()
		return nil
	case userthreadsubscription.FieldSubscribedAt:
		m.ResetSubscribedAt()
		return nil
	}
	return fmt.Errorf("unknown UserThreadSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserThreadSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userthreadsubscription.EdgeUser)
	}
	if m.thread != nil {
		edges = append(edges, userthreadsubscription.EdgeThread)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserThreadSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userthreadsubscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userthreadsubscription.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserThreadSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserThreadSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserThreadSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userthreadsubscription.EdgeUser)
	}
	if m.clearedthread {
		edges = append(edges, userthreadsubscription.EdgeThread)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserThreadSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case userthreadsubscription.EdgeUser:
		return m.cleareduser
	case userthreadsubscription.EdgeThread:
		return m.clearedthread
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserThreadSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case userthreadsubscription.EdgeUser:
		m.ClearUser()
		return nil
	case userthreadsubscription.EdgeThread:
		m.ClearThread()
		return nil
	}
	return fmt.Errorf("unknown UserThreadSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserThreadSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case userthreadsubscription.EdgeUser:
		m.ResetUser()
		return nil
	case userthreadsubscription.EdgeThread:
		m.ResetThread()
		return nil
	}
	return fmt.Errorf("unknown UserThreadSubscription edge %s", name)
}
