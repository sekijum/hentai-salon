// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"server/infrastructure/ent/board"
	"server/infrastructure/ent/predicate"
	"server/infrastructure/ent/tag"
	"server/infrastructure/ent/thread"
	"server/infrastructure/ent/threadcomment"
	"server/infrastructure/ent/threadcommentattachment"
	"server/infrastructure/ent/threadtag"
	"server/infrastructure/ent/user"
	"server/infrastructure/ent/usercommentlike"
	"server/infrastructure/ent/usercommentsubscription"
	"server/infrastructure/ent/userthreadlike"
	"server/infrastructure/ent/userthreadsubscription"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBoard                   = "Board"
	TypeTag                     = "Tag"
	TypeThread                  = "Thread"
	TypeThreadComment           = "ThreadComment"
	TypeThreadCommentAttachment = "ThreadCommentAttachment"
	TypeThreadTag               = "ThreadTag"
	TypeUser                    = "User"
	TypeUserCommentLike         = "UserCommentLike"
	TypeUserCommentSubscription = "UserCommentSubscription"
	TypeUserThreadLike          = "UserThreadLike"
	TypeUserThreadSubscription  = "UserThreadSubscription"
)

// BoardMutation represents an operation that mutates the Board nodes in the graph.
type BoardMutation struct {
	config
	op             Op
	typ            string
	id             *int
	title          *string
	description    *string
	thumbnail_url  *string
	status         *int
	addstatus      *int
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	owner          *int
	clearedowner   bool
	threads        map[int]struct{}
	removedthreads map[int]struct{}
	clearedthreads bool
	done           bool
	oldValue       func(context.Context) (*Board, error)
	predicates     []predicate.Board
}

var _ ent.Mutation = (*BoardMutation)(nil)

// boardOption allows management of the mutation configuration using functional options.
type boardOption func(*BoardMutation)

// newBoardMutation creates new mutation for the Board entity.
func newBoardMutation(c config, op Op, opts ...boardOption) *BoardMutation {
	m := &BoardMutation{
		config:        c,
		op:            op,
		typ:           TypeBoard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBoardID sets the ID field of the mutation.
func withBoardID(id int) boardOption {
	return func(m *BoardMutation) {
		var (
			err   error
			once  sync.Once
			value *Board
		)
		m.oldValue = func(ctx context.Context) (*Board, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Board.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBoard sets the old Board of the mutation.
func withBoard(node *Board) boardOption {
	return func(m *BoardMutation) {
		m.oldValue = func(context.Context) (*Board, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BoardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BoardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Board entities.
func (m *BoardMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BoardMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BoardMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Board.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *BoardMutation) SetUserID(i int) {
	m.owner = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BoardMutation) UserID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BoardMutation) ResetUserID() {
	m.owner = nil
}

// SetTitle sets the "title" field.
func (m *BoardMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BoardMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BoardMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BoardMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BoardMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BoardMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[board.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BoardMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[board.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BoardMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, board.FieldDescription)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *BoardMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *BoardMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldThumbnailURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *BoardMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[board.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *BoardMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[board.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *BoardMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, board.FieldThumbnailURL)
}

// SetStatus sets the "status" field.
func (m *BoardMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BoardMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BoardMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BoardMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *BoardMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BoardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BoardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BoardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BoardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BoardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Board entity.
// If the Board object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BoardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BoardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *BoardMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *BoardMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[board.FieldUserID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *BoardMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *BoardMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *BoardMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *BoardMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *BoardMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *BoardMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *BoardMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *BoardMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *BoardMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *BoardMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *BoardMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// Where appends a list predicates to the BoardMutation builder.
func (m *BoardMutation) Where(ps ...predicate.Board) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BoardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BoardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Board, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BoardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BoardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Board).
func (m *BoardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BoardMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.owner != nil {
		fields = append(fields, board.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, board.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, board.FieldDescription)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, board.FieldThumbnailURL)
	}
	if m.status != nil {
		fields = append(fields, board.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, board.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, board.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BoardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case board.FieldUserID:
		return m.UserID()
	case board.FieldTitle:
		return m.Title()
	case board.FieldDescription:
		return m.Description()
	case board.FieldThumbnailURL:
		return m.ThumbnailURL()
	case board.FieldStatus:
		return m.Status()
	case board.FieldCreatedAt:
		return m.CreatedAt()
	case board.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BoardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case board.FieldUserID:
		return m.OldUserID(ctx)
	case board.FieldTitle:
		return m.OldTitle(ctx)
	case board.FieldDescription:
		return m.OldDescription(ctx)
	case board.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case board.FieldStatus:
		return m.OldStatus(ctx)
	case board.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case board.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Board field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BoardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case board.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case board.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case board.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case board.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case board.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case board.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case board.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Board field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BoardMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, board.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BoardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case board.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BoardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case board.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Board numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BoardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(board.FieldDescription) {
		fields = append(fields, board.FieldDescription)
	}
	if m.FieldCleared(board.FieldThumbnailURL) {
		fields = append(fields, board.FieldThumbnailURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BoardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BoardMutation) ClearField(name string) error {
	switch name {
	case board.FieldDescription:
		m.ClearDescription()
		return nil
	case board.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	}
	return fmt.Errorf("unknown Board nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BoardMutation) ResetField(name string) error {
	switch name {
	case board.FieldUserID:
		m.ResetUserID()
		return nil
	case board.FieldTitle:
		m.ResetTitle()
		return nil
	case board.FieldDescription:
		m.ResetDescription()
		return nil
	case board.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case board.FieldStatus:
		m.ResetStatus()
		return nil
	case board.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case board.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Board field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BoardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, board.EdgeOwner)
	}
	if m.threads != nil {
		edges = append(edges, board.EdgeThreads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BoardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case board.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case board.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BoardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedthreads != nil {
		edges = append(edges, board.EdgeThreads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BoardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case board.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BoardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, board.EdgeOwner)
	}
	if m.clearedthreads {
		edges = append(edges, board.EdgeThreads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BoardMutation) EdgeCleared(name string) bool {
	switch name {
	case board.EdgeOwner:
		return m.clearedowner
	case board.EdgeThreads:
		return m.clearedthreads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BoardMutation) ClearEdge(name string) error {
	switch name {
	case board.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Board unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BoardMutation) ResetEdge(name string) error {
	switch name {
	case board.EdgeOwner:
		m.ResetOwner()
		return nil
	case board.EdgeThreads:
		m.ResetThreads()
		return nil
	}
	return fmt.Errorf("unknown Board edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	threads        map[int]struct{}
	removedthreads map[int]struct{}
	clearedthreads bool
	done           bool
	oldValue       func(context.Context) (*Tag, error)
	predicates     []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *TagMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *TagMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *TagMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *TagMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *TagMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *TagMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *TagMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldName:
		return m.Name()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.threads != nil {
		edges = append(edges, tag.EdgeThreads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedthreads != nil {
		edges = append(edges, tag.EdgeThreads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedthreads {
		edges = append(edges, tag.EdgeThreads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeThreads:
		return m.clearedthreads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeThreads:
		m.ResetThreads()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// ThreadMutation represents an operation that mutates the Thread nodes in the graph.
type ThreadMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	title                   *string
	description             *string
	thumbnail_url           *string
	ip_address              *string
	status                  *int
	addstatus               *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	board                   *int
	clearedboard            bool
	owner                   *int
	clearedowner            bool
	comments                map[int]struct{}
	removedcomments         map[int]struct{}
	clearedcomments         bool
	tags                    map[int]struct{}
	removedtags             map[int]struct{}
	clearedtags             bool
	liked_users             map[int]struct{}
	removedliked_users      map[int]struct{}
	clearedliked_users      bool
	subscribed_users        map[int]struct{}
	removedsubscribed_users map[int]struct{}
	clearedsubscribed_users bool
	done                    bool
	oldValue                func(context.Context) (*Thread, error)
	predicates              []predicate.Thread
}

var _ ent.Mutation = (*ThreadMutation)(nil)

// threadOption allows management of the mutation configuration using functional options.
type threadOption func(*ThreadMutation)

// newThreadMutation creates new mutation for the Thread entity.
func newThreadMutation(c config, op Op, opts ...threadOption) *ThreadMutation {
	m := &ThreadMutation{
		config:        c,
		op:            op,
		typ:           TypeThread,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadID sets the ID field of the mutation.
func withThreadID(id int) threadOption {
	return func(m *ThreadMutation) {
		var (
			err   error
			once  sync.Once
			value *Thread
		)
		m.oldValue = func(ctx context.Context) (*Thread, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Thread.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThread sets the old Thread of the mutation.
func withThread(node *Thread) threadOption {
	return func(m *ThreadMutation) {
		m.oldValue = func(context.Context) (*Thread, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Thread entities.
func (m *ThreadMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Thread.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBoardID sets the "board_id" field.
func (m *ThreadMutation) SetBoardID(i int) {
	m.board = &i
}

// BoardID returns the value of the "board_id" field in the mutation.
func (m *ThreadMutation) BoardID() (r int, exists bool) {
	v := m.board
	if v == nil {
		return
	}
	return *v, true
}

// OldBoardID returns the old "board_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldBoardID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoardID: %w", err)
	}
	return oldValue.BoardID, nil
}

// ResetBoardID resets all changes to the "board_id" field.
func (m *ThreadMutation) ResetBoardID() {
	m.board = nil
}

// SetUserID sets the "user_id" field.
func (m *ThreadMutation) SetUserID(i int) {
	m.owner = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ThreadMutation) UserID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ThreadMutation) ResetUserID() {
	m.owner = nil
}

// SetTitle sets the "title" field.
func (m *ThreadMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ThreadMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ThreadMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ThreadMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ThreadMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ThreadMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[thread.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ThreadMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[thread.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ThreadMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, thread.FieldDescription)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *ThreadMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *ThreadMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldThumbnailURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *ThreadMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[thread.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *ThreadMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[thread.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *ThreadMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, thread.FieldThumbnailURL)
}

// SetIPAddress sets the "ip_address" field.
func (m *ThreadMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *ThreadMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *ThreadMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetStatus sets the "status" field.
func (m *ThreadMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ThreadMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ThreadMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ThreadMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ThreadMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ThreadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThreadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThreadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ThreadMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ThreadMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ThreadMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearBoard clears the "board" edge to the Board entity.
func (m *ThreadMutation) ClearBoard() {
	m.clearedboard = true
	m.clearedFields[thread.FieldBoardID] = struct{}{}
}

// BoardCleared reports if the "board" edge to the Board entity was cleared.
func (m *ThreadMutation) BoardCleared() bool {
	return m.clearedboard
}

// BoardIDs returns the "board" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BoardID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) BoardIDs() (ids []int) {
	if id := m.board; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBoard resets all changes to the "board" edge.
func (m *ThreadMutation) ResetBoard() {
	m.board = nil
	m.clearedboard = false
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *ThreadMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ThreadMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[thread.FieldUserID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ThreadMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ThreadMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ThreadMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddCommentIDs adds the "comments" edge to the ThreadComment entity by ids.
func (m *ThreadMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the ThreadComment entity.
func (m *ThreadMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the ThreadComment entity was cleared.
func (m *ThreadMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the ThreadComment entity by IDs.
func (m *ThreadMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the ThreadComment entity.
func (m *ThreadMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *ThreadMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *ThreadMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ThreadMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ThreadMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ThreadMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ThreadMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ThreadMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ThreadMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ThreadMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddLikedUserIDs adds the "liked_users" edge to the User entity by ids.
func (m *ThreadMutation) AddLikedUserIDs(ids ...int) {
	if m.liked_users == nil {
		m.liked_users = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_users[ids[i]] = struct{}{}
	}
}

// ClearLikedUsers clears the "liked_users" edge to the User entity.
func (m *ThreadMutation) ClearLikedUsers() {
	m.clearedliked_users = true
}

// LikedUsersCleared reports if the "liked_users" edge to the User entity was cleared.
func (m *ThreadMutation) LikedUsersCleared() bool {
	return m.clearedliked_users
}

// RemoveLikedUserIDs removes the "liked_users" edge to the User entity by IDs.
func (m *ThreadMutation) RemoveLikedUserIDs(ids ...int) {
	if m.removedliked_users == nil {
		m.removedliked_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_users, ids[i])
		m.removedliked_users[ids[i]] = struct{}{}
	}
}

// RemovedLikedUsers returns the removed IDs of the "liked_users" edge to the User entity.
func (m *ThreadMutation) RemovedLikedUsersIDs() (ids []int) {
	for id := range m.removedliked_users {
		ids = append(ids, id)
	}
	return
}

// LikedUsersIDs returns the "liked_users" edge IDs in the mutation.
func (m *ThreadMutation) LikedUsersIDs() (ids []int) {
	for id := range m.liked_users {
		ids = append(ids, id)
	}
	return
}

// ResetLikedUsers resets all changes to the "liked_users" edge.
func (m *ThreadMutation) ResetLikedUsers() {
	m.liked_users = nil
	m.clearedliked_users = false
	m.removedliked_users = nil
}

// AddSubscribedUserIDs adds the "subscribed_users" edge to the User entity by ids.
func (m *ThreadMutation) AddSubscribedUserIDs(ids ...int) {
	if m.subscribed_users == nil {
		m.subscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_users[ids[i]] = struct{}{}
	}
}

// ClearSubscribedUsers clears the "subscribed_users" edge to the User entity.
func (m *ThreadMutation) ClearSubscribedUsers() {
	m.clearedsubscribed_users = true
}

// SubscribedUsersCleared reports if the "subscribed_users" edge to the User entity was cleared.
func (m *ThreadMutation) SubscribedUsersCleared() bool {
	return m.clearedsubscribed_users
}

// RemoveSubscribedUserIDs removes the "subscribed_users" edge to the User entity by IDs.
func (m *ThreadMutation) RemoveSubscribedUserIDs(ids ...int) {
	if m.removedsubscribed_users == nil {
		m.removedsubscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_users, ids[i])
		m.removedsubscribed_users[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedUsers returns the removed IDs of the "subscribed_users" edge to the User entity.
func (m *ThreadMutation) RemovedSubscribedUsersIDs() (ids []int) {
	for id := range m.removedsubscribed_users {
		ids = append(ids, id)
	}
	return
}

// SubscribedUsersIDs returns the "subscribed_users" edge IDs in the mutation.
func (m *ThreadMutation) SubscribedUsersIDs() (ids []int) {
	for id := range m.subscribed_users {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedUsers resets all changes to the "subscribed_users" edge.
func (m *ThreadMutation) ResetSubscribedUsers() {
	m.subscribed_users = nil
	m.clearedsubscribed_users = false
	m.removedsubscribed_users = nil
}

// Where appends a list predicates to the ThreadMutation builder.
func (m *ThreadMutation) Where(ps ...predicate.Thread) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Thread, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Thread).
func (m *ThreadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.board != nil {
		fields = append(fields, thread.FieldBoardID)
	}
	if m.owner != nil {
		fields = append(fields, thread.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, thread.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, thread.FieldDescription)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, thread.FieldThumbnailURL)
	}
	if m.ip_address != nil {
		fields = append(fields, thread.FieldIPAddress)
	}
	if m.status != nil {
		fields = append(fields, thread.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, thread.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, thread.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldBoardID:
		return m.BoardID()
	case thread.FieldUserID:
		return m.UserID()
	case thread.FieldTitle:
		return m.Title()
	case thread.FieldDescription:
		return m.Description()
	case thread.FieldThumbnailURL:
		return m.ThumbnailURL()
	case thread.FieldIPAddress:
		return m.IPAddress()
	case thread.FieldStatus:
		return m.Status()
	case thread.FieldCreatedAt:
		return m.CreatedAt()
	case thread.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case thread.FieldBoardID:
		return m.OldBoardID(ctx)
	case thread.FieldUserID:
		return m.OldUserID(ctx)
	case thread.FieldTitle:
		return m.OldTitle(ctx)
	case thread.FieldDescription:
		return m.OldDescription(ctx)
	case thread.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case thread.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case thread.FieldStatus:
		return m.OldStatus(ctx)
	case thread.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case thread.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Thread field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case thread.FieldBoardID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoardID(v)
		return nil
	case thread.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case thread.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case thread.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case thread.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case thread.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case thread.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case thread.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case thread.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, thread.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case thread.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Thread numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(thread.FieldDescription) {
		fields = append(fields, thread.FieldDescription)
	}
	if m.FieldCleared(thread.FieldThumbnailURL) {
		fields = append(fields, thread.FieldThumbnailURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadMutation) ClearField(name string) error {
	switch name {
	case thread.FieldDescription:
		m.ClearDescription()
		return nil
	case thread.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	}
	return fmt.Errorf("unknown Thread nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadMutation) ResetField(name string) error {
	switch name {
	case thread.FieldBoardID:
		m.ResetBoardID()
		return nil
	case thread.FieldUserID:
		m.ResetUserID()
		return nil
	case thread.FieldTitle:
		m.ResetTitle()
		return nil
	case thread.FieldDescription:
		m.ResetDescription()
		return nil
	case thread.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case thread.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case thread.FieldStatus:
		m.ResetStatus()
		return nil
	case thread.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case thread.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.board != nil {
		edges = append(edges, thread.EdgeBoard)
	}
	if m.owner != nil {
		edges = append(edges, thread.EdgeOwner)
	}
	if m.comments != nil {
		edges = append(edges, thread.EdgeComments)
	}
	if m.tags != nil {
		edges = append(edges, thread.EdgeTags)
	}
	if m.liked_users != nil {
		edges = append(edges, thread.EdgeLikedUsers)
	}
	if m.subscribed_users != nil {
		edges = append(edges, thread.EdgeSubscribedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeBoard:
		if id := m.board; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.liked_users))
		for id := range m.liked_users {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.subscribed_users))
		for id := range m.subscribed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcomments != nil {
		edges = append(edges, thread.EdgeComments)
	}
	if m.removedtags != nil {
		edges = append(edges, thread.EdgeTags)
	}
	if m.removedliked_users != nil {
		edges = append(edges, thread.EdgeLikedUsers)
	}
	if m.removedsubscribed_users != nil {
		edges = append(edges, thread.EdgeSubscribedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.removedliked_users))
		for id := range m.removedliked_users {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_users))
		for id := range m.removedsubscribed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedboard {
		edges = append(edges, thread.EdgeBoard)
	}
	if m.clearedowner {
		edges = append(edges, thread.EdgeOwner)
	}
	if m.clearedcomments {
		edges = append(edges, thread.EdgeComments)
	}
	if m.clearedtags {
		edges = append(edges, thread.EdgeTags)
	}
	if m.clearedliked_users {
		edges = append(edges, thread.EdgeLikedUsers)
	}
	if m.clearedsubscribed_users {
		edges = append(edges, thread.EdgeSubscribedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadMutation) EdgeCleared(name string) bool {
	switch name {
	case thread.EdgeBoard:
		return m.clearedboard
	case thread.EdgeOwner:
		return m.clearedowner
	case thread.EdgeComments:
		return m.clearedcomments
	case thread.EdgeTags:
		return m.clearedtags
	case thread.EdgeLikedUsers:
		return m.clearedliked_users
	case thread.EdgeSubscribedUsers:
		return m.clearedsubscribed_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadMutation) ClearEdge(name string) error {
	switch name {
	case thread.EdgeBoard:
		m.ClearBoard()
		return nil
	case thread.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Thread unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadMutation) ResetEdge(name string) error {
	switch name {
	case thread.EdgeBoard:
		m.ResetBoard()
		return nil
	case thread.EdgeOwner:
		m.ResetOwner()
		return nil
	case thread.EdgeComments:
		m.ResetComments()
		return nil
	case thread.EdgeTags:
		m.ResetTags()
		return nil
	case thread.EdgeLikedUsers:
		m.ResetLikedUsers()
		return nil
	case thread.EdgeSubscribedUsers:
		m.ResetSubscribedUsers()
		return nil
	}
	return fmt.Errorf("unknown Thread edge %s", name)
}

// ThreadCommentMutation represents an operation that mutates the ThreadComment nodes in the graph.
type ThreadCommentMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	guest_name              *string
	content                 *string
	ip_address              *string
	status                  *int
	addstatus               *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	thread                  *int
	clearedthread           bool
	author                  *int
	clearedauthor           bool
	parent_comment          *int
	clearedparent_comment   bool
	replies                 map[int]struct{}
	removedreplies          map[int]struct{}
	clearedreplies          bool
	attachments             map[int]struct{}
	removedattachments      map[int]struct{}
	clearedattachments      bool
	liked_users             map[int]struct{}
	removedliked_users      map[int]struct{}
	clearedliked_users      bool
	subscribed_users        map[int]struct{}
	removedsubscribed_users map[int]struct{}
	clearedsubscribed_users bool
	done                    bool
	oldValue                func(context.Context) (*ThreadComment, error)
	predicates              []predicate.ThreadComment
}

var _ ent.Mutation = (*ThreadCommentMutation)(nil)

// threadcommentOption allows management of the mutation configuration using functional options.
type threadcommentOption func(*ThreadCommentMutation)

// newThreadCommentMutation creates new mutation for the ThreadComment entity.
func newThreadCommentMutation(c config, op Op, opts ...threadcommentOption) *ThreadCommentMutation {
	m := &ThreadCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadCommentID sets the ID field of the mutation.
func withThreadCommentID(id int) threadcommentOption {
	return func(m *ThreadCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *ThreadComment
		)
		m.oldValue = func(ctx context.Context) (*ThreadComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ThreadComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThreadComment sets the old ThreadComment of the mutation.
func withThreadComment(node *ThreadComment) threadcommentOption {
	return func(m *ThreadCommentMutation) {
		m.oldValue = func(context.Context) (*ThreadComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ThreadComment entities.
func (m *ThreadCommentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadCommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadCommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ThreadComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetThreadID sets the "thread_id" field.
func (m *ThreadCommentMutation) SetThreadID(i int) {
	m.thread = &i
}

// ThreadID returns the value of the "thread_id" field in the mutation.
func (m *ThreadCommentMutation) ThreadID() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// OldThreadID returns the old "thread_id" field's value of the ThreadComment entity.
// If the ThreadComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentMutation) OldThreadID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreadID: %w", err)
	}
	return oldValue.ThreadID, nil
}

// ResetThreadID resets all changes to the "thread_id" field.
func (m *ThreadCommentMutation) ResetThreadID() {
	m.thread = nil
}

// SetParentCommentID sets the "parent_comment_id" field.
func (m *ThreadCommentMutation) SetParentCommentID(i int) {
	m.parent_comment = &i
}

// ParentCommentID returns the value of the "parent_comment_id" field in the mutation.
func (m *ThreadCommentMutation) ParentCommentID() (r int, exists bool) {
	v := m.parent_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldParentCommentID returns the old "parent_comment_id" field's value of the ThreadComment entity.
// If the ThreadComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentMutation) OldParentCommentID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentCommentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentCommentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentCommentID: %w", err)
	}
	return oldValue.ParentCommentID, nil
}

// ClearParentCommentID clears the value of the "parent_comment_id" field.
func (m *ThreadCommentMutation) ClearParentCommentID() {
	m.parent_comment = nil
	m.clearedFields[threadcomment.FieldParentCommentID] = struct{}{}
}

// ParentCommentIDCleared returns if the "parent_comment_id" field was cleared in this mutation.
func (m *ThreadCommentMutation) ParentCommentIDCleared() bool {
	_, ok := m.clearedFields[threadcomment.FieldParentCommentID]
	return ok
}

// ResetParentCommentID resets all changes to the "parent_comment_id" field.
func (m *ThreadCommentMutation) ResetParentCommentID() {
	m.parent_comment = nil
	delete(m.clearedFields, threadcomment.FieldParentCommentID)
}

// SetUserID sets the "user_id" field.
func (m *ThreadCommentMutation) SetUserID(i int) {
	m.author = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ThreadCommentMutation) UserID() (r int, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ThreadComment entity.
// If the ThreadComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentMutation) OldUserID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ThreadCommentMutation) ClearUserID() {
	m.author = nil
	m.clearedFields[threadcomment.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ThreadCommentMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[threadcomment.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ThreadCommentMutation) ResetUserID() {
	m.author = nil
	delete(m.clearedFields, threadcomment.FieldUserID)
}

// SetGuestName sets the "guest_name" field.
func (m *ThreadCommentMutation) SetGuestName(s string) {
	m.guest_name = &s
}

// GuestName returns the value of the "guest_name" field in the mutation.
func (m *ThreadCommentMutation) GuestName() (r string, exists bool) {
	v := m.guest_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGuestName returns the old "guest_name" field's value of the ThreadComment entity.
// If the ThreadComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentMutation) OldGuestName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuestName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuestName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuestName: %w", err)
	}
	return oldValue.GuestName, nil
}

// ClearGuestName clears the value of the "guest_name" field.
func (m *ThreadCommentMutation) ClearGuestName() {
	m.guest_name = nil
	m.clearedFields[threadcomment.FieldGuestName] = struct{}{}
}

// GuestNameCleared returns if the "guest_name" field was cleared in this mutation.
func (m *ThreadCommentMutation) GuestNameCleared() bool {
	_, ok := m.clearedFields[threadcomment.FieldGuestName]
	return ok
}

// ResetGuestName resets all changes to the "guest_name" field.
func (m *ThreadCommentMutation) ResetGuestName() {
	m.guest_name = nil
	delete(m.clearedFields, threadcomment.FieldGuestName)
}

// SetContent sets the "content" field.
func (m *ThreadCommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ThreadCommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the ThreadComment entity.
// If the ThreadComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ThreadCommentMutation) ResetContent() {
	m.content = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *ThreadCommentMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *ThreadCommentMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the ThreadComment entity.
// If the ThreadComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *ThreadCommentMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetStatus sets the "status" field.
func (m *ThreadCommentMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ThreadCommentMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ThreadComment entity.
// If the ThreadComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ThreadCommentMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ThreadCommentMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ThreadCommentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ThreadCommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThreadCommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ThreadComment entity.
// If the ThreadComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThreadCommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ThreadCommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ThreadCommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ThreadComment entity.
// If the ThreadComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ThreadCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *ThreadCommentMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[threadcomment.FieldThreadID] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *ThreadCommentMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *ThreadCommentMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *ThreadCommentMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *ThreadCommentMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *ThreadCommentMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[threadcomment.FieldUserID] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *ThreadCommentMutation) AuthorCleared() bool {
	return m.UserIDCleared() || m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *ThreadCommentMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *ThreadCommentMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *ThreadCommentMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// ClearParentComment clears the "parent_comment" edge to the ThreadComment entity.
func (m *ThreadCommentMutation) ClearParentComment() {
	m.clearedparent_comment = true
	m.clearedFields[threadcomment.FieldParentCommentID] = struct{}{}
}

// ParentCommentCleared reports if the "parent_comment" edge to the ThreadComment entity was cleared.
func (m *ThreadCommentMutation) ParentCommentCleared() bool {
	return m.ParentCommentIDCleared() || m.clearedparent_comment
}

// ParentCommentIDs returns the "parent_comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentCommentID instead. It exists only for internal usage by the builders.
func (m *ThreadCommentMutation) ParentCommentIDs() (ids []int) {
	if id := m.parent_comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentComment resets all changes to the "parent_comment" edge.
func (m *ThreadCommentMutation) ResetParentComment() {
	m.parent_comment = nil
	m.clearedparent_comment = false
}

// AddReplyIDs adds the "replies" edge to the ThreadComment entity by ids.
func (m *ThreadCommentMutation) AddReplyIDs(ids ...int) {
	if m.replies == nil {
		m.replies = make(map[int]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the ThreadComment entity.
func (m *ThreadCommentMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the ThreadComment entity was cleared.
func (m *ThreadCommentMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the ThreadComment entity by IDs.
func (m *ThreadCommentMutation) RemoveReplyIDs(ids ...int) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the ThreadComment entity.
func (m *ThreadCommentMutation) RemovedRepliesIDs() (ids []int) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *ThreadCommentMutation) RepliesIDs() (ids []int) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *ThreadCommentMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// AddAttachmentIDs adds the "attachments" edge to the ThreadCommentAttachment entity by ids.
func (m *ThreadCommentMutation) AddAttachmentIDs(ids ...int) {
	if m.attachments == nil {
		m.attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the ThreadCommentAttachment entity.
func (m *ThreadCommentMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the ThreadCommentAttachment entity was cleared.
func (m *ThreadCommentMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the ThreadCommentAttachment entity by IDs.
func (m *ThreadCommentMutation) RemoveAttachmentIDs(ids ...int) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the ThreadCommentAttachment entity.
func (m *ThreadCommentMutation) RemovedAttachmentsIDs() (ids []int) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *ThreadCommentMutation) AttachmentsIDs() (ids []int) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *ThreadCommentMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// AddLikedUserIDs adds the "liked_users" edge to the User entity by ids.
func (m *ThreadCommentMutation) AddLikedUserIDs(ids ...int) {
	if m.liked_users == nil {
		m.liked_users = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_users[ids[i]] = struct{}{}
	}
}

// ClearLikedUsers clears the "liked_users" edge to the User entity.
func (m *ThreadCommentMutation) ClearLikedUsers() {
	m.clearedliked_users = true
}

// LikedUsersCleared reports if the "liked_users" edge to the User entity was cleared.
func (m *ThreadCommentMutation) LikedUsersCleared() bool {
	return m.clearedliked_users
}

// RemoveLikedUserIDs removes the "liked_users" edge to the User entity by IDs.
func (m *ThreadCommentMutation) RemoveLikedUserIDs(ids ...int) {
	if m.removedliked_users == nil {
		m.removedliked_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_users, ids[i])
		m.removedliked_users[ids[i]] = struct{}{}
	}
}

// RemovedLikedUsers returns the removed IDs of the "liked_users" edge to the User entity.
func (m *ThreadCommentMutation) RemovedLikedUsersIDs() (ids []int) {
	for id := range m.removedliked_users {
		ids = append(ids, id)
	}
	return
}

// LikedUsersIDs returns the "liked_users" edge IDs in the mutation.
func (m *ThreadCommentMutation) LikedUsersIDs() (ids []int) {
	for id := range m.liked_users {
		ids = append(ids, id)
	}
	return
}

// ResetLikedUsers resets all changes to the "liked_users" edge.
func (m *ThreadCommentMutation) ResetLikedUsers() {
	m.liked_users = nil
	m.clearedliked_users = false
	m.removedliked_users = nil
}

// AddSubscribedUserIDs adds the "subscribed_users" edge to the User entity by ids.
func (m *ThreadCommentMutation) AddSubscribedUserIDs(ids ...int) {
	if m.subscribed_users == nil {
		m.subscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_users[ids[i]] = struct{}{}
	}
}

// ClearSubscribedUsers clears the "subscribed_users" edge to the User entity.
func (m *ThreadCommentMutation) ClearSubscribedUsers() {
	m.clearedsubscribed_users = true
}

// SubscribedUsersCleared reports if the "subscribed_users" edge to the User entity was cleared.
func (m *ThreadCommentMutation) SubscribedUsersCleared() bool {
	return m.clearedsubscribed_users
}

// RemoveSubscribedUserIDs removes the "subscribed_users" edge to the User entity by IDs.
func (m *ThreadCommentMutation) RemoveSubscribedUserIDs(ids ...int) {
	if m.removedsubscribed_users == nil {
		m.removedsubscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_users, ids[i])
		m.removedsubscribed_users[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedUsers returns the removed IDs of the "subscribed_users" edge to the User entity.
func (m *ThreadCommentMutation) RemovedSubscribedUsersIDs() (ids []int) {
	for id := range m.removedsubscribed_users {
		ids = append(ids, id)
	}
	return
}

// SubscribedUsersIDs returns the "subscribed_users" edge IDs in the mutation.
func (m *ThreadCommentMutation) SubscribedUsersIDs() (ids []int) {
	for id := range m.subscribed_users {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedUsers resets all changes to the "subscribed_users" edge.
func (m *ThreadCommentMutation) ResetSubscribedUsers() {
	m.subscribed_users = nil
	m.clearedsubscribed_users = false
	m.removedsubscribed_users = nil
}

// Where appends a list predicates to the ThreadCommentMutation builder.
func (m *ThreadCommentMutation) Where(ps ...predicate.ThreadComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadComment).
func (m *ThreadCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadCommentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.thread != nil {
		fields = append(fields, threadcomment.FieldThreadID)
	}
	if m.parent_comment != nil {
		fields = append(fields, threadcomment.FieldParentCommentID)
	}
	if m.author != nil {
		fields = append(fields, threadcomment.FieldUserID)
	}
	if m.guest_name != nil {
		fields = append(fields, threadcomment.FieldGuestName)
	}
	if m.content != nil {
		fields = append(fields, threadcomment.FieldContent)
	}
	if m.ip_address != nil {
		fields = append(fields, threadcomment.FieldIPAddress)
	}
	if m.status != nil {
		fields = append(fields, threadcomment.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, threadcomment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, threadcomment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threadcomment.FieldThreadID:
		return m.ThreadID()
	case threadcomment.FieldParentCommentID:
		return m.ParentCommentID()
	case threadcomment.FieldUserID:
		return m.UserID()
	case threadcomment.FieldGuestName:
		return m.GuestName()
	case threadcomment.FieldContent:
		return m.Content()
	case threadcomment.FieldIPAddress:
		return m.IPAddress()
	case threadcomment.FieldStatus:
		return m.Status()
	case threadcomment.FieldCreatedAt:
		return m.CreatedAt()
	case threadcomment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case threadcomment.FieldThreadID:
		return m.OldThreadID(ctx)
	case threadcomment.FieldParentCommentID:
		return m.OldParentCommentID(ctx)
	case threadcomment.FieldUserID:
		return m.OldUserID(ctx)
	case threadcomment.FieldGuestName:
		return m.OldGuestName(ctx)
	case threadcomment.FieldContent:
		return m.OldContent(ctx)
	case threadcomment.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case threadcomment.FieldStatus:
		return m.OldStatus(ctx)
	case threadcomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case threadcomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ThreadComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threadcomment.FieldThreadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadID(v)
		return nil
	case threadcomment.FieldParentCommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentCommentID(v)
		return nil
	case threadcomment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case threadcomment.FieldGuestName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuestName(v)
		return nil
	case threadcomment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case threadcomment.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case threadcomment.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case threadcomment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case threadcomment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadCommentMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, threadcomment.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case threadcomment.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case threadcomment.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadCommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(threadcomment.FieldParentCommentID) {
		fields = append(fields, threadcomment.FieldParentCommentID)
	}
	if m.FieldCleared(threadcomment.FieldUserID) {
		fields = append(fields, threadcomment.FieldUserID)
	}
	if m.FieldCleared(threadcomment.FieldGuestName) {
		fields = append(fields, threadcomment.FieldGuestName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadCommentMutation) ClearField(name string) error {
	switch name {
	case threadcomment.FieldParentCommentID:
		m.ClearParentCommentID()
		return nil
	case threadcomment.FieldUserID:
		m.ClearUserID()
		return nil
	case threadcomment.FieldGuestName:
		m.ClearGuestName()
		return nil
	}
	return fmt.Errorf("unknown ThreadComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadCommentMutation) ResetField(name string) error {
	switch name {
	case threadcomment.FieldThreadID:
		m.ResetThreadID()
		return nil
	case threadcomment.FieldParentCommentID:
		m.ResetParentCommentID()
		return nil
	case threadcomment.FieldUserID:
		m.ResetUserID()
		return nil
	case threadcomment.FieldGuestName:
		m.ResetGuestName()
		return nil
	case threadcomment.FieldContent:
		m.ResetContent()
		return nil
	case threadcomment.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case threadcomment.FieldStatus:
		m.ResetStatus()
		return nil
	case threadcomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case threadcomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ThreadComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.thread != nil {
		edges = append(edges, threadcomment.EdgeThread)
	}
	if m.author != nil {
		edges = append(edges, threadcomment.EdgeAuthor)
	}
	if m.parent_comment != nil {
		edges = append(edges, threadcomment.EdgeParentComment)
	}
	if m.replies != nil {
		edges = append(edges, threadcomment.EdgeReplies)
	}
	if m.attachments != nil {
		edges = append(edges, threadcomment.EdgeAttachments)
	}
	if m.liked_users != nil {
		edges = append(edges, threadcomment.EdgeLikedUsers)
	}
	if m.subscribed_users != nil {
		edges = append(edges, threadcomment.EdgeSubscribedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case threadcomment.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	case threadcomment.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case threadcomment.EdgeParentComment:
		if id := m.parent_comment; id != nil {
			return []ent.Value{*id}
		}
	case threadcomment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	case threadcomment.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	case threadcomment.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.liked_users))
		for id := range m.liked_users {
			ids = append(ids, id)
		}
		return ids
	case threadcomment.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.subscribed_users))
		for id := range m.subscribed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedreplies != nil {
		edges = append(edges, threadcomment.EdgeReplies)
	}
	if m.removedattachments != nil {
		edges = append(edges, threadcomment.EdgeAttachments)
	}
	if m.removedliked_users != nil {
		edges = append(edges, threadcomment.EdgeLikedUsers)
	}
	if m.removedsubscribed_users != nil {
		edges = append(edges, threadcomment.EdgeSubscribedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadCommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case threadcomment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	case threadcomment.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	case threadcomment.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.removedliked_users))
		for id := range m.removedliked_users {
			ids = append(ids, id)
		}
		return ids
	case threadcomment.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_users))
		for id := range m.removedsubscribed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedthread {
		edges = append(edges, threadcomment.EdgeThread)
	}
	if m.clearedauthor {
		edges = append(edges, threadcomment.EdgeAuthor)
	}
	if m.clearedparent_comment {
		edges = append(edges, threadcomment.EdgeParentComment)
	}
	if m.clearedreplies {
		edges = append(edges, threadcomment.EdgeReplies)
	}
	if m.clearedattachments {
		edges = append(edges, threadcomment.EdgeAttachments)
	}
	if m.clearedliked_users {
		edges = append(edges, threadcomment.EdgeLikedUsers)
	}
	if m.clearedsubscribed_users {
		edges = append(edges, threadcomment.EdgeSubscribedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case threadcomment.EdgeThread:
		return m.clearedthread
	case threadcomment.EdgeAuthor:
		return m.clearedauthor
	case threadcomment.EdgeParentComment:
		return m.clearedparent_comment
	case threadcomment.EdgeReplies:
		return m.clearedreplies
	case threadcomment.EdgeAttachments:
		return m.clearedattachments
	case threadcomment.EdgeLikedUsers:
		return m.clearedliked_users
	case threadcomment.EdgeSubscribedUsers:
		return m.clearedsubscribed_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadCommentMutation) ClearEdge(name string) error {
	switch name {
	case threadcomment.EdgeThread:
		m.ClearThread()
		return nil
	case threadcomment.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case threadcomment.EdgeParentComment:
		m.ClearParentComment()
		return nil
	}
	return fmt.Errorf("unknown ThreadComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadCommentMutation) ResetEdge(name string) error {
	switch name {
	case threadcomment.EdgeThread:
		m.ResetThread()
		return nil
	case threadcomment.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case threadcomment.EdgeParentComment:
		m.ResetParentComment()
		return nil
	case threadcomment.EdgeReplies:
		m.ResetReplies()
		return nil
	case threadcomment.EdgeAttachments:
		m.ResetAttachments()
		return nil
	case threadcomment.EdgeLikedUsers:
		m.ResetLikedUsers()
		return nil
	case threadcomment.EdgeSubscribedUsers:
		m.ResetSubscribedUsers()
		return nil
	}
	return fmt.Errorf("unknown ThreadComment edge %s", name)
}

// ThreadCommentAttachmentMutation represents an operation that mutates the ThreadCommentAttachment nodes in the graph.
type ThreadCommentAttachmentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	url              *string
	display_order    *int
	adddisplay_order *int
	_type            *int
	add_type         *int
	created_at       *time.Time
	clearedFields    map[string]struct{}
	comment          *int
	clearedcomment   bool
	done             bool
	oldValue         func(context.Context) (*ThreadCommentAttachment, error)
	predicates       []predicate.ThreadCommentAttachment
}

var _ ent.Mutation = (*ThreadCommentAttachmentMutation)(nil)

// threadcommentattachmentOption allows management of the mutation configuration using functional options.
type threadcommentattachmentOption func(*ThreadCommentAttachmentMutation)

// newThreadCommentAttachmentMutation creates new mutation for the ThreadCommentAttachment entity.
func newThreadCommentAttachmentMutation(c config, op Op, opts ...threadcommentattachmentOption) *ThreadCommentAttachmentMutation {
	m := &ThreadCommentAttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadCommentAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadCommentAttachmentID sets the ID field of the mutation.
func withThreadCommentAttachmentID(id int) threadcommentattachmentOption {
	return func(m *ThreadCommentAttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *ThreadCommentAttachment
		)
		m.oldValue = func(ctx context.Context) (*ThreadCommentAttachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ThreadCommentAttachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThreadCommentAttachment sets the old ThreadCommentAttachment of the mutation.
func withThreadCommentAttachment(node *ThreadCommentAttachment) threadcommentattachmentOption {
	return func(m *ThreadCommentAttachmentMutation) {
		m.oldValue = func(context.Context) (*ThreadCommentAttachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadCommentAttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadCommentAttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ThreadCommentAttachment entities.
func (m *ThreadCommentAttachmentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadCommentAttachmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadCommentAttachmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ThreadCommentAttachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCommentID sets the "comment_id" field.
func (m *ThreadCommentAttachmentMutation) SetCommentID(i int) {
	m.comment = &i
}

// CommentID returns the value of the "comment_id" field in the mutation.
func (m *ThreadCommentAttachmentMutation) CommentID() (r int, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentID returns the old "comment_id" field's value of the ThreadCommentAttachment entity.
// If the ThreadCommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentAttachmentMutation) OldCommentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentID: %w", err)
	}
	return oldValue.CommentID, nil
}

// ResetCommentID resets all changes to the "comment_id" field.
func (m *ThreadCommentAttachmentMutation) ResetCommentID() {
	m.comment = nil
}

// SetURL sets the "url" field.
func (m *ThreadCommentAttachmentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ThreadCommentAttachmentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the ThreadCommentAttachment entity.
// If the ThreadCommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentAttachmentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ThreadCommentAttachmentMutation) ResetURL() {
	m.url = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *ThreadCommentAttachmentMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *ThreadCommentAttachmentMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the ThreadCommentAttachment entity.
// If the ThreadCommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentAttachmentMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *ThreadCommentAttachmentMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *ThreadCommentAttachmentMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *ThreadCommentAttachmentMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// SetType sets the "type" field.
func (m *ThreadCommentAttachmentMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *ThreadCommentAttachmentMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ThreadCommentAttachment entity.
// If the ThreadCommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentAttachmentMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *ThreadCommentAttachmentMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *ThreadCommentAttachmentMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *ThreadCommentAttachmentMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ThreadCommentAttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThreadCommentAttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ThreadCommentAttachment entity.
// If the ThreadCommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCommentAttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThreadCommentAttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearComment clears the "comment" edge to the ThreadComment entity.
func (m *ThreadCommentAttachmentMutation) ClearComment() {
	m.clearedcomment = true
	m.clearedFields[threadcommentattachment.FieldCommentID] = struct{}{}
}

// CommentCleared reports if the "comment" edge to the ThreadComment entity was cleared.
func (m *ThreadCommentAttachmentMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *ThreadCommentAttachmentMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *ThreadCommentAttachmentMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the ThreadCommentAttachmentMutation builder.
func (m *ThreadCommentAttachmentMutation) Where(ps ...predicate.ThreadCommentAttachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadCommentAttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadCommentAttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadCommentAttachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadCommentAttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadCommentAttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadCommentAttachment).
func (m *ThreadCommentAttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadCommentAttachmentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.comment != nil {
		fields = append(fields, threadcommentattachment.FieldCommentID)
	}
	if m.url != nil {
		fields = append(fields, threadcommentattachment.FieldURL)
	}
	if m.display_order != nil {
		fields = append(fields, threadcommentattachment.FieldDisplayOrder)
	}
	if m._type != nil {
		fields = append(fields, threadcommentattachment.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, threadcommentattachment.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadCommentAttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threadcommentattachment.FieldCommentID:
		return m.CommentID()
	case threadcommentattachment.FieldURL:
		return m.URL()
	case threadcommentattachment.FieldDisplayOrder:
		return m.DisplayOrder()
	case threadcommentattachment.FieldType:
		return m.GetType()
	case threadcommentattachment.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadCommentAttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case threadcommentattachment.FieldCommentID:
		return m.OldCommentID(ctx)
	case threadcommentattachment.FieldURL:
		return m.OldURL(ctx)
	case threadcommentattachment.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	case threadcommentattachment.FieldType:
		return m.OldType(ctx)
	case threadcommentattachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ThreadCommentAttachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadCommentAttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threadcommentattachment.FieldCommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentID(v)
		return nil
	case threadcommentattachment.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case threadcommentattachment.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	case threadcommentattachment.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case threadcommentattachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadCommentAttachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadCommentAttachmentMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, threadcommentattachment.FieldDisplayOrder)
	}
	if m.add_type != nil {
		fields = append(fields, threadcommentattachment.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadCommentAttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case threadcommentattachment.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	case threadcommentattachment.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadCommentAttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case threadcommentattachment.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	case threadcommentattachment.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadCommentAttachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadCommentAttachmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadCommentAttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadCommentAttachmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ThreadCommentAttachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadCommentAttachmentMutation) ResetField(name string) error {
	switch name {
	case threadcommentattachment.FieldCommentID:
		m.ResetCommentID()
		return nil
	case threadcommentattachment.FieldURL:
		m.ResetURL()
		return nil
	case threadcommentattachment.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	case threadcommentattachment.FieldType:
		m.ResetType()
		return nil
	case threadcommentattachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ThreadCommentAttachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadCommentAttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.comment != nil {
		edges = append(edges, threadcommentattachment.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadCommentAttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case threadcommentattachment.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadCommentAttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadCommentAttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadCommentAttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcomment {
		edges = append(edges, threadcommentattachment.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadCommentAttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case threadcommentattachment.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadCommentAttachmentMutation) ClearEdge(name string) error {
	switch name {
	case threadcommentattachment.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown ThreadCommentAttachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadCommentAttachmentMutation) ResetEdge(name string) error {
	switch name {
	case threadcommentattachment.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown ThreadCommentAttachment edge %s", name)
}

// ThreadTagMutation represents an operation that mutates the ThreadTag nodes in the graph.
type ThreadTagMutation struct {
	config
	op            Op
	typ           string
	clearedFields map[string]struct{}
	thread        *int
	clearedthread bool
	tag           *int
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*ThreadTag, error)
	predicates    []predicate.ThreadTag
}

var _ ent.Mutation = (*ThreadTagMutation)(nil)

// threadtagOption allows management of the mutation configuration using functional options.
type threadtagOption func(*ThreadTagMutation)

// newThreadTagMutation creates new mutation for the ThreadTag entity.
func newThreadTagMutation(c config, op Op, opts ...threadtagOption) *ThreadTagMutation {
	m := &ThreadTagMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetThreadID sets the "thread_id" field.
func (m *ThreadTagMutation) SetThreadID(i int) {
	m.thread = &i
}

// ThreadID returns the value of the "thread_id" field in the mutation.
func (m *ThreadTagMutation) ThreadID() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// ResetThreadID resets all changes to the "thread_id" field.
func (m *ThreadTagMutation) ResetThreadID() {
	m.thread = nil
}

// SetTagID sets the "tag_id" field.
func (m *ThreadTagMutation) SetTagID(i int) {
	m.tag = &i
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *ThreadTagMutation) TagID() (r int, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *ThreadTagMutation) ResetTagID() {
	m.tag = nil
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *ThreadTagMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[threadtag.FieldThreadID] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *ThreadTagMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *ThreadTagMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *ThreadTagMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *ThreadTagMutation) ClearTag() {
	m.clearedtag = true
	m.clearedFields[threadtag.FieldTagID] = struct{}{}
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *ThreadTagMutation) TagCleared() bool {
	return m.clearedtag
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *ThreadTagMutation) TagIDs() (ids []int) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *ThreadTagMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// Where appends a list predicates to the ThreadTagMutation builder.
func (m *ThreadTagMutation) Where(ps ...predicate.ThreadTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadTag).
func (m *ThreadTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.thread != nil {
		fields = append(fields, threadtag.FieldThreadID)
	}
	if m.tag != nil {
		fields = append(fields, threadtag.FieldTagID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threadtag.FieldThreadID:
		return m.ThreadID()
	case threadtag.FieldTagID:
		return m.TagID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema ThreadTag does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threadtag.FieldThreadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadID(v)
		return nil
	case threadtag.FieldTagID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadTagMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ThreadTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ThreadTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadTagMutation) ResetField(name string) error {
	switch name {
	case threadtag.FieldThreadID:
		m.ResetThreadID()
		return nil
	case threadtag.FieldTagID:
		m.ResetTagID()
		return nil
	}
	return fmt.Errorf("unknown ThreadTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.thread != nil {
		edges = append(edges, threadtag.EdgeThread)
	}
	if m.tag != nil {
		edges = append(edges, threadtag.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case threadtag.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	case threadtag.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadTagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedthread {
		edges = append(edges, threadtag.EdgeThread)
	}
	if m.clearedtag {
		edges = append(edges, threadtag.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadTagMutation) EdgeCleared(name string) bool {
	switch name {
	case threadtag.EdgeThread:
		return m.clearedthread
	case threadtag.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadTagMutation) ClearEdge(name string) error {
	switch name {
	case threadtag.EdgeThread:
		m.ClearThread()
		return nil
	case threadtag.EdgeTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown ThreadTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadTagMutation) ResetEdge(name string) error {
	switch name {
	case threadtag.EdgeThread:
		m.ResetThread()
		return nil
	case threadtag.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown ThreadTag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	name                       *string
	email                      *string
	password                   *string
	profile_link               *string
	avatar_url                 *string
	status                     *int
	addstatus                  *int
	role                       *int
	addrole                    *int
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	boards                     map[int]struct{}
	removedboards              map[int]struct{}
	clearedboards              bool
	threads                    map[int]struct{}
	removedthreads             map[int]struct{}
	clearedthreads             bool
	comments                   map[int]struct{}
	removedcomments            map[int]struct{}
	clearedcomments            bool
	liked_threads              map[int]struct{}
	removedliked_threads       map[int]struct{}
	clearedliked_threads       bool
	liked_comments             map[int]struct{}
	removedliked_comments      map[int]struct{}
	clearedliked_comments      bool
	subscribed_threads         map[int]struct{}
	removedsubscribed_threads  map[int]struct{}
	clearedsubscribed_threads  bool
	subscribed_comments        map[int]struct{}
	removedsubscribed_comments map[int]struct{}
	clearedsubscribed_comments bool
	done                       bool
	oldValue                   func(context.Context) (*User, error)
	predicates                 []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetProfileLink sets the "profile_link" field.
func (m *UserMutation) SetProfileLink(s string) {
	m.profile_link = &s
}

// ProfileLink returns the value of the "profile_link" field in the mutation.
func (m *UserMutation) ProfileLink() (r string, exists bool) {
	v := m.profile_link
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileLink returns the old "profile_link" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfileLink(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileLink: %w", err)
	}
	return oldValue.ProfileLink, nil
}

// ClearProfileLink clears the value of the "profile_link" field.
func (m *UserMutation) ClearProfileLink() {
	m.profile_link = nil
	m.clearedFields[user.FieldProfileLink] = struct{}{}
}

// ProfileLinkCleared returns if the "profile_link" field was cleared in this mutation.
func (m *UserMutation) ProfileLinkCleared() bool {
	_, ok := m.clearedFields[user.FieldProfileLink]
	return ok
}

// ResetProfileLink resets all changes to the "profile_link" field.
func (m *UserMutation) ResetProfileLink() {
	m.profile_link = nil
	delete(m.clearedFields, user.FieldProfileLink)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(i int) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *UserMutation) AddRole(i int) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *UserMutation) AddedRole() (r int, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBoardIDs adds the "boards" edge to the Board entity by ids.
func (m *UserMutation) AddBoardIDs(ids ...int) {
	if m.boards == nil {
		m.boards = make(map[int]struct{})
	}
	for i := range ids {
		m.boards[ids[i]] = struct{}{}
	}
}

// ClearBoards clears the "boards" edge to the Board entity.
func (m *UserMutation) ClearBoards() {
	m.clearedboards = true
}

// BoardsCleared reports if the "boards" edge to the Board entity was cleared.
func (m *UserMutation) BoardsCleared() bool {
	return m.clearedboards
}

// RemoveBoardIDs removes the "boards" edge to the Board entity by IDs.
func (m *UserMutation) RemoveBoardIDs(ids ...int) {
	if m.removedboards == nil {
		m.removedboards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.boards, ids[i])
		m.removedboards[ids[i]] = struct{}{}
	}
}

// RemovedBoards returns the removed IDs of the "boards" edge to the Board entity.
func (m *UserMutation) RemovedBoardsIDs() (ids []int) {
	for id := range m.removedboards {
		ids = append(ids, id)
	}
	return
}

// BoardsIDs returns the "boards" edge IDs in the mutation.
func (m *UserMutation) BoardsIDs() (ids []int) {
	for id := range m.boards {
		ids = append(ids, id)
	}
	return
}

// ResetBoards resets all changes to the "boards" edge.
func (m *UserMutation) ResetBoards() {
	m.boards = nil
	m.clearedboards = false
	m.removedboards = nil
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *UserMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *UserMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *UserMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *UserMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *UserMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *UserMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *UserMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// AddCommentIDs adds the "comments" edge to the ThreadComment entity by ids.
func (m *UserMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the ThreadComment entity.
func (m *UserMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the ThreadComment entity was cleared.
func (m *UserMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the ThreadComment entity by IDs.
func (m *UserMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the ThreadComment entity.
func (m *UserMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *UserMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddLikedThreadIDs adds the "liked_threads" edge to the Thread entity by ids.
func (m *UserMutation) AddLikedThreadIDs(ids ...int) {
	if m.liked_threads == nil {
		m.liked_threads = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_threads[ids[i]] = struct{}{}
	}
}

// ClearLikedThreads clears the "liked_threads" edge to the Thread entity.
func (m *UserMutation) ClearLikedThreads() {
	m.clearedliked_threads = true
}

// LikedThreadsCleared reports if the "liked_threads" edge to the Thread entity was cleared.
func (m *UserMutation) LikedThreadsCleared() bool {
	return m.clearedliked_threads
}

// RemoveLikedThreadIDs removes the "liked_threads" edge to the Thread entity by IDs.
func (m *UserMutation) RemoveLikedThreadIDs(ids ...int) {
	if m.removedliked_threads == nil {
		m.removedliked_threads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_threads, ids[i])
		m.removedliked_threads[ids[i]] = struct{}{}
	}
}

// RemovedLikedThreads returns the removed IDs of the "liked_threads" edge to the Thread entity.
func (m *UserMutation) RemovedLikedThreadsIDs() (ids []int) {
	for id := range m.removedliked_threads {
		ids = append(ids, id)
	}
	return
}

// LikedThreadsIDs returns the "liked_threads" edge IDs in the mutation.
func (m *UserMutation) LikedThreadsIDs() (ids []int) {
	for id := range m.liked_threads {
		ids = append(ids, id)
	}
	return
}

// ResetLikedThreads resets all changes to the "liked_threads" edge.
func (m *UserMutation) ResetLikedThreads() {
	m.liked_threads = nil
	m.clearedliked_threads = false
	m.removedliked_threads = nil
}

// AddLikedCommentIDs adds the "liked_comments" edge to the ThreadComment entity by ids.
func (m *UserMutation) AddLikedCommentIDs(ids ...int) {
	if m.liked_comments == nil {
		m.liked_comments = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_comments[ids[i]] = struct{}{}
	}
}

// ClearLikedComments clears the "liked_comments" edge to the ThreadComment entity.
func (m *UserMutation) ClearLikedComments() {
	m.clearedliked_comments = true
}

// LikedCommentsCleared reports if the "liked_comments" edge to the ThreadComment entity was cleared.
func (m *UserMutation) LikedCommentsCleared() bool {
	return m.clearedliked_comments
}

// RemoveLikedCommentIDs removes the "liked_comments" edge to the ThreadComment entity by IDs.
func (m *UserMutation) RemoveLikedCommentIDs(ids ...int) {
	if m.removedliked_comments == nil {
		m.removedliked_comments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_comments, ids[i])
		m.removedliked_comments[ids[i]] = struct{}{}
	}
}

// RemovedLikedComments returns the removed IDs of the "liked_comments" edge to the ThreadComment entity.
func (m *UserMutation) RemovedLikedCommentsIDs() (ids []int) {
	for id := range m.removedliked_comments {
		ids = append(ids, id)
	}
	return
}

// LikedCommentsIDs returns the "liked_comments" edge IDs in the mutation.
func (m *UserMutation) LikedCommentsIDs() (ids []int) {
	for id := range m.liked_comments {
		ids = append(ids, id)
	}
	return
}

// ResetLikedComments resets all changes to the "liked_comments" edge.
func (m *UserMutation) ResetLikedComments() {
	m.liked_comments = nil
	m.clearedliked_comments = false
	m.removedliked_comments = nil
}

// AddSubscribedThreadIDs adds the "subscribed_threads" edge to the Thread entity by ids.
func (m *UserMutation) AddSubscribedThreadIDs(ids ...int) {
	if m.subscribed_threads == nil {
		m.subscribed_threads = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_threads[ids[i]] = struct{}{}
	}
}

// ClearSubscribedThreads clears the "subscribed_threads" edge to the Thread entity.
func (m *UserMutation) ClearSubscribedThreads() {
	m.clearedsubscribed_threads = true
}

// SubscribedThreadsCleared reports if the "subscribed_threads" edge to the Thread entity was cleared.
func (m *UserMutation) SubscribedThreadsCleared() bool {
	return m.clearedsubscribed_threads
}

// RemoveSubscribedThreadIDs removes the "subscribed_threads" edge to the Thread entity by IDs.
func (m *UserMutation) RemoveSubscribedThreadIDs(ids ...int) {
	if m.removedsubscribed_threads == nil {
		m.removedsubscribed_threads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_threads, ids[i])
		m.removedsubscribed_threads[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedThreads returns the removed IDs of the "subscribed_threads" edge to the Thread entity.
func (m *UserMutation) RemovedSubscribedThreadsIDs() (ids []int) {
	for id := range m.removedsubscribed_threads {
		ids = append(ids, id)
	}
	return
}

// SubscribedThreadsIDs returns the "subscribed_threads" edge IDs in the mutation.
func (m *UserMutation) SubscribedThreadsIDs() (ids []int) {
	for id := range m.subscribed_threads {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedThreads resets all changes to the "subscribed_threads" edge.
func (m *UserMutation) ResetSubscribedThreads() {
	m.subscribed_threads = nil
	m.clearedsubscribed_threads = false
	m.removedsubscribed_threads = nil
}

// AddSubscribedCommentIDs adds the "subscribed_comments" edge to the ThreadComment entity by ids.
func (m *UserMutation) AddSubscribedCommentIDs(ids ...int) {
	if m.subscribed_comments == nil {
		m.subscribed_comments = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_comments[ids[i]] = struct{}{}
	}
}

// ClearSubscribedComments clears the "subscribed_comments" edge to the ThreadComment entity.
func (m *UserMutation) ClearSubscribedComments() {
	m.clearedsubscribed_comments = true
}

// SubscribedCommentsCleared reports if the "subscribed_comments" edge to the ThreadComment entity was cleared.
func (m *UserMutation) SubscribedCommentsCleared() bool {
	return m.clearedsubscribed_comments
}

// RemoveSubscribedCommentIDs removes the "subscribed_comments" edge to the ThreadComment entity by IDs.
func (m *UserMutation) RemoveSubscribedCommentIDs(ids ...int) {
	if m.removedsubscribed_comments == nil {
		m.removedsubscribed_comments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_comments, ids[i])
		m.removedsubscribed_comments[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedComments returns the removed IDs of the "subscribed_comments" edge to the ThreadComment entity.
func (m *UserMutation) RemovedSubscribedCommentsIDs() (ids []int) {
	for id := range m.removedsubscribed_comments {
		ids = append(ids, id)
	}
	return
}

// SubscribedCommentsIDs returns the "subscribed_comments" edge IDs in the mutation.
func (m *UserMutation) SubscribedCommentsIDs() (ids []int) {
	for id := range m.subscribed_comments {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedComments resets all changes to the "subscribed_comments" edge.
func (m *UserMutation) ResetSubscribedComments() {
	m.subscribed_comments = nil
	m.clearedsubscribed_comments = false
	m.removedsubscribed_comments = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.profile_link != nil {
		fields = append(fields, user.FieldProfileLink)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldProfileLink:
		return m.ProfileLink()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldStatus:
		return m.Status()
	case user.FieldRole:
		return m.Role()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldProfileLink:
		return m.OldProfileLink(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldProfileLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileLink(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.addrole != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.AddedStatus()
	case user.FieldRole:
		return m.AddedRole()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case user.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldProfileLink) {
		fields = append(fields, user.FieldProfileLink)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldProfileLink:
		m.ClearProfileLink()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldProfileLink:
		m.ResetProfileLink()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.boards != nil {
		edges = append(edges, user.EdgeBoards)
	}
	if m.threads != nil {
		edges = append(edges, user.EdgeThreads)
	}
	if m.comments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.liked_threads != nil {
		edges = append(edges, user.EdgeLikedThreads)
	}
	if m.liked_comments != nil {
		edges = append(edges, user.EdgeLikedComments)
	}
	if m.subscribed_threads != nil {
		edges = append(edges, user.EdgeSubscribedThreads)
	}
	if m.subscribed_comments != nil {
		edges = append(edges, user.EdgeSubscribedComments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBoards:
		ids := make([]ent.Value, 0, len(m.boards))
		for id := range m.boards {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedThreads:
		ids := make([]ent.Value, 0, len(m.liked_threads))
		for id := range m.liked_threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedComments:
		ids := make([]ent.Value, 0, len(m.liked_comments))
		for id := range m.liked_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedThreads:
		ids := make([]ent.Value, 0, len(m.subscribed_threads))
		for id := range m.subscribed_threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedComments:
		ids := make([]ent.Value, 0, len(m.subscribed_comments))
		for id := range m.subscribed_comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedboards != nil {
		edges = append(edges, user.EdgeBoards)
	}
	if m.removedthreads != nil {
		edges = append(edges, user.EdgeThreads)
	}
	if m.removedcomments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.removedliked_threads != nil {
		edges = append(edges, user.EdgeLikedThreads)
	}
	if m.removedliked_comments != nil {
		edges = append(edges, user.EdgeLikedComments)
	}
	if m.removedsubscribed_threads != nil {
		edges = append(edges, user.EdgeSubscribedThreads)
	}
	if m.removedsubscribed_comments != nil {
		edges = append(edges, user.EdgeSubscribedComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBoards:
		ids := make([]ent.Value, 0, len(m.removedboards))
		for id := range m.removedboards {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedThreads:
		ids := make([]ent.Value, 0, len(m.removedliked_threads))
		for id := range m.removedliked_threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedComments:
		ids := make([]ent.Value, 0, len(m.removedliked_comments))
		for id := range m.removedliked_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedThreads:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_threads))
		for id := range m.removedsubscribed_threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedComments:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_comments))
		for id := range m.removedsubscribed_comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedboards {
		edges = append(edges, user.EdgeBoards)
	}
	if m.clearedthreads {
		edges = append(edges, user.EdgeThreads)
	}
	if m.clearedcomments {
		edges = append(edges, user.EdgeComments)
	}
	if m.clearedliked_threads {
		edges = append(edges, user.EdgeLikedThreads)
	}
	if m.clearedliked_comments {
		edges = append(edges, user.EdgeLikedComments)
	}
	if m.clearedsubscribed_threads {
		edges = append(edges, user.EdgeSubscribedThreads)
	}
	if m.clearedsubscribed_comments {
		edges = append(edges, user.EdgeSubscribedComments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBoards:
		return m.clearedboards
	case user.EdgeThreads:
		return m.clearedthreads
	case user.EdgeComments:
		return m.clearedcomments
	case user.EdgeLikedThreads:
		return m.clearedliked_threads
	case user.EdgeLikedComments:
		return m.clearedliked_comments
	case user.EdgeSubscribedThreads:
		return m.clearedsubscribed_threads
	case user.EdgeSubscribedComments:
		return m.clearedsubscribed_comments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBoards:
		m.ResetBoards()
		return nil
	case user.EdgeThreads:
		m.ResetThreads()
		return nil
	case user.EdgeComments:
		m.ResetComments()
		return nil
	case user.EdgeLikedThreads:
		m.ResetLikedThreads()
		return nil
	case user.EdgeLikedComments:
		m.ResetLikedComments()
		return nil
	case user.EdgeSubscribedThreads:
		m.ResetSubscribedThreads()
		return nil
	case user.EdgeSubscribedComments:
		m.ResetSubscribedComments()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserCommentLikeMutation represents an operation that mutates the UserCommentLike nodes in the graph.
type UserCommentLikeMutation struct {
	config
	op             Op
	typ            string
	liked_at       *time.Time
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	comment        *int
	clearedcomment bool
	done           bool
	oldValue       func(context.Context) (*UserCommentLike, error)
	predicates     []predicate.UserCommentLike
}

var _ ent.Mutation = (*UserCommentLikeMutation)(nil)

// usercommentlikeOption allows management of the mutation configuration using functional options.
type usercommentlikeOption func(*UserCommentLikeMutation)

// newUserCommentLikeMutation creates new mutation for the UserCommentLike entity.
func newUserCommentLikeMutation(c config, op Op, opts ...usercommentlikeOption) *UserCommentLikeMutation {
	m := &UserCommentLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCommentLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCommentLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCommentLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserID sets the "user_id" field.
func (m *UserCommentLikeMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserCommentLikeMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserCommentLikeMutation) ResetUserID() {
	m.user = nil
}

// SetCommentID sets the "comment_id" field.
func (m *UserCommentLikeMutation) SetCommentID(i int) {
	m.comment = &i
}

// CommentID returns the value of the "comment_id" field in the mutation.
func (m *UserCommentLikeMutation) CommentID() (r int, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentID resets all changes to the "comment_id" field.
func (m *UserCommentLikeMutation) ResetCommentID() {
	m.comment = nil
}

// SetLikedAt sets the "liked_at" field.
func (m *UserCommentLikeMutation) SetLikedAt(t time.Time) {
	m.liked_at = &t
}

// LikedAt returns the value of the "liked_at" field in the mutation.
func (m *UserCommentLikeMutation) LikedAt() (r time.Time, exists bool) {
	v := m.liked_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikedAt resets all changes to the "liked_at" field.
func (m *UserCommentLikeMutation) ResetLikedAt() {
	m.liked_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserCommentLikeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usercommentlike.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserCommentLikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserCommentLikeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserCommentLikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearComment clears the "comment" edge to the ThreadComment entity.
func (m *UserCommentLikeMutation) ClearComment() {
	m.clearedcomment = true
	m.clearedFields[usercommentlike.FieldCommentID] = struct{}{}
}

// CommentCleared reports if the "comment" edge to the ThreadComment entity was cleared.
func (m *UserCommentLikeMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *UserCommentLikeMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *UserCommentLikeMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the UserCommentLikeMutation builder.
func (m *UserCommentLikeMutation) Where(ps ...predicate.UserCommentLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCommentLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCommentLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCommentLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCommentLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCommentLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCommentLike).
func (m *UserCommentLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCommentLikeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, usercommentlike.FieldUserID)
	}
	if m.comment != nil {
		fields = append(fields, usercommentlike.FieldCommentID)
	}
	if m.liked_at != nil {
		fields = append(fields, usercommentlike.FieldLikedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCommentLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercommentlike.FieldUserID:
		return m.UserID()
	case usercommentlike.FieldCommentID:
		return m.CommentID()
	case usercommentlike.FieldLikedAt:
		return m.LikedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCommentLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserCommentLike does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCommentLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercommentlike.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usercommentlike.FieldCommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentID(v)
		return nil
	case usercommentlike.FieldLikedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserCommentLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCommentLikeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCommentLikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCommentLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCommentLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCommentLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCommentLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCommentLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserCommentLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCommentLikeMutation) ResetField(name string) error {
	switch name {
	case usercommentlike.FieldUserID:
		m.ResetUserID()
		return nil
	case usercommentlike.FieldCommentID:
		m.ResetCommentID()
		return nil
	case usercommentlike.FieldLikedAt:
		m.ResetLikedAt()
		return nil
	}
	return fmt.Errorf("unknown UserCommentLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCommentLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usercommentlike.EdgeUser)
	}
	if m.comment != nil {
		edges = append(edges, usercommentlike.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCommentLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercommentlike.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usercommentlike.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCommentLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCommentLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCommentLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usercommentlike.EdgeUser)
	}
	if m.clearedcomment {
		edges = append(edges, usercommentlike.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCommentLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case usercommentlike.EdgeUser:
		return m.cleareduser
	case usercommentlike.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCommentLikeMutation) ClearEdge(name string) error {
	switch name {
	case usercommentlike.EdgeUser:
		m.ClearUser()
		return nil
	case usercommentlike.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown UserCommentLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCommentLikeMutation) ResetEdge(name string) error {
	switch name {
	case usercommentlike.EdgeUser:
		m.ResetUser()
		return nil
	case usercommentlike.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown UserCommentLike edge %s", name)
}

// UserCommentSubscriptionMutation represents an operation that mutates the UserCommentSubscription nodes in the graph.
type UserCommentSubscriptionMutation struct {
	config
	op             Op
	typ            string
	is_notified    *bool
	is_checked     *bool
	subscribed_at  *time.Time
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	comment        *int
	clearedcomment bool
	done           bool
	oldValue       func(context.Context) (*UserCommentSubscription, error)
	predicates     []predicate.UserCommentSubscription
}

var _ ent.Mutation = (*UserCommentSubscriptionMutation)(nil)

// usercommentsubscriptionOption allows management of the mutation configuration using functional options.
type usercommentsubscriptionOption func(*UserCommentSubscriptionMutation)

// newUserCommentSubscriptionMutation creates new mutation for the UserCommentSubscription entity.
func newUserCommentSubscriptionMutation(c config, op Op, opts ...usercommentsubscriptionOption) *UserCommentSubscriptionMutation {
	m := &UserCommentSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCommentSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCommentSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCommentSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserID sets the "user_id" field.
func (m *UserCommentSubscriptionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserCommentSubscriptionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserCommentSubscriptionMutation) ResetUserID() {
	m.user = nil
}

// SetCommentID sets the "comment_id" field.
func (m *UserCommentSubscriptionMutation) SetCommentID(i int) {
	m.comment = &i
}

// CommentID returns the value of the "comment_id" field in the mutation.
func (m *UserCommentSubscriptionMutation) CommentID() (r int, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentID resets all changes to the "comment_id" field.
func (m *UserCommentSubscriptionMutation) ResetCommentID() {
	m.comment = nil
}

// SetIsNotified sets the "is_notified" field.
func (m *UserCommentSubscriptionMutation) SetIsNotified(b bool) {
	m.is_notified = &b
}

// IsNotified returns the value of the "is_notified" field in the mutation.
func (m *UserCommentSubscriptionMutation) IsNotified() (r bool, exists bool) {
	v := m.is_notified
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsNotified resets all changes to the "is_notified" field.
func (m *UserCommentSubscriptionMutation) ResetIsNotified() {
	m.is_notified = nil
}

// SetIsChecked sets the "is_checked" field.
func (m *UserCommentSubscriptionMutation) SetIsChecked(b bool) {
	m.is_checked = &b
}

// IsChecked returns the value of the "is_checked" field in the mutation.
func (m *UserCommentSubscriptionMutation) IsChecked() (r bool, exists bool) {
	v := m.is_checked
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsChecked resets all changes to the "is_checked" field.
func (m *UserCommentSubscriptionMutation) ResetIsChecked() {
	m.is_checked = nil
}

// SetSubscribedAt sets the "subscribed_at" field.
func (m *UserCommentSubscriptionMutation) SetSubscribedAt(t time.Time) {
	m.subscribed_at = &t
}

// SubscribedAt returns the value of the "subscribed_at" field in the mutation.
func (m *UserCommentSubscriptionMutation) SubscribedAt() (r time.Time, exists bool) {
	v := m.subscribed_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubscribedAt resets all changes to the "subscribed_at" field.
func (m *UserCommentSubscriptionMutation) ResetSubscribedAt() {
	m.subscribed_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserCommentSubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usercommentsubscription.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserCommentSubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserCommentSubscriptionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserCommentSubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearComment clears the "comment" edge to the ThreadComment entity.
func (m *UserCommentSubscriptionMutation) ClearComment() {
	m.clearedcomment = true
	m.clearedFields[usercommentsubscription.FieldCommentID] = struct{}{}
}

// CommentCleared reports if the "comment" edge to the ThreadComment entity was cleared.
func (m *UserCommentSubscriptionMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *UserCommentSubscriptionMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *UserCommentSubscriptionMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the UserCommentSubscriptionMutation builder.
func (m *UserCommentSubscriptionMutation) Where(ps ...predicate.UserCommentSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCommentSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCommentSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCommentSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCommentSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCommentSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCommentSubscription).
func (m *UserCommentSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCommentSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, usercommentsubscription.FieldUserID)
	}
	if m.comment != nil {
		fields = append(fields, usercommentsubscription.FieldCommentID)
	}
	if m.is_notified != nil {
		fields = append(fields, usercommentsubscription.FieldIsNotified)
	}
	if m.is_checked != nil {
		fields = append(fields, usercommentsubscription.FieldIsChecked)
	}
	if m.subscribed_at != nil {
		fields = append(fields, usercommentsubscription.FieldSubscribedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCommentSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercommentsubscription.FieldUserID:
		return m.UserID()
	case usercommentsubscription.FieldCommentID:
		return m.CommentID()
	case usercommentsubscription.FieldIsNotified:
		return m.IsNotified()
	case usercommentsubscription.FieldIsChecked:
		return m.IsChecked()
	case usercommentsubscription.FieldSubscribedAt:
		return m.SubscribedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCommentSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserCommentSubscription does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCommentSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercommentsubscription.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usercommentsubscription.FieldCommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentID(v)
		return nil
	case usercommentsubscription.FieldIsNotified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNotified(v)
		return nil
	case usercommentsubscription.FieldIsChecked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsChecked(v)
		return nil
	case usercommentsubscription.FieldSubscribedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserCommentSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCommentSubscriptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCommentSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCommentSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCommentSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCommentSubscriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCommentSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCommentSubscriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserCommentSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCommentSubscriptionMutation) ResetField(name string) error {
	switch name {
	case usercommentsubscription.FieldUserID:
		m.ResetUserID()
		return nil
	case usercommentsubscription.FieldCommentID:
		m.ResetCommentID()
		return nil
	case usercommentsubscription.FieldIsNotified:
		m.ResetIsNotified()
		return nil
	case usercommentsubscription.FieldIsChecked:
		m.ResetIsChecked()
		return nil
	case usercommentsubscription.FieldSubscribedAt:
		m.ResetSubscribedAt()
		return nil
	}
	return fmt.Errorf("unknown UserCommentSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCommentSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usercommentsubscription.EdgeUser)
	}
	if m.comment != nil {
		edges = append(edges, usercommentsubscription.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCommentSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercommentsubscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usercommentsubscription.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCommentSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCommentSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCommentSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usercommentsubscription.EdgeUser)
	}
	if m.clearedcomment {
		edges = append(edges, usercommentsubscription.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCommentSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case usercommentsubscription.EdgeUser:
		return m.cleareduser
	case usercommentsubscription.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCommentSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case usercommentsubscription.EdgeUser:
		m.ClearUser()
		return nil
	case usercommentsubscription.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown UserCommentSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCommentSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case usercommentsubscription.EdgeUser:
		m.ResetUser()
		return nil
	case usercommentsubscription.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown UserCommentSubscription edge %s", name)
}

// UserThreadLikeMutation represents an operation that mutates the UserThreadLike nodes in the graph.
type UserThreadLikeMutation struct {
	config
	op            Op
	typ           string
	liked_at      *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	thread        *int
	clearedthread bool
	done          bool
	oldValue      func(context.Context) (*UserThreadLike, error)
	predicates    []predicate.UserThreadLike
}

var _ ent.Mutation = (*UserThreadLikeMutation)(nil)

// userthreadlikeOption allows management of the mutation configuration using functional options.
type userthreadlikeOption func(*UserThreadLikeMutation)

// newUserThreadLikeMutation creates new mutation for the UserThreadLike entity.
func newUserThreadLikeMutation(c config, op Op, opts ...userthreadlikeOption) *UserThreadLikeMutation {
	m := &UserThreadLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserThreadLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserThreadLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserThreadLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserID sets the "user_id" field.
func (m *UserThreadLikeMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserThreadLikeMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserThreadLikeMutation) ResetUserID() {
	m.user = nil
}

// SetThreadID sets the "thread_id" field.
func (m *UserThreadLikeMutation) SetThreadID(i int) {
	m.thread = &i
}

// ThreadID returns the value of the "thread_id" field in the mutation.
func (m *UserThreadLikeMutation) ThreadID() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// ResetThreadID resets all changes to the "thread_id" field.
func (m *UserThreadLikeMutation) ResetThreadID() {
	m.thread = nil
}

// SetLikedAt sets the "liked_at" field.
func (m *UserThreadLikeMutation) SetLikedAt(t time.Time) {
	m.liked_at = &t
}

// LikedAt returns the value of the "liked_at" field in the mutation.
func (m *UserThreadLikeMutation) LikedAt() (r time.Time, exists bool) {
	v := m.liked_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikedAt resets all changes to the "liked_at" field.
func (m *UserThreadLikeMutation) ResetLikedAt() {
	m.liked_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserThreadLikeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userthreadlike.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserThreadLikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserThreadLikeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserThreadLikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *UserThreadLikeMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[userthreadlike.FieldThreadID] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *UserThreadLikeMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *UserThreadLikeMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *UserThreadLikeMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// Where appends a list predicates to the UserThreadLikeMutation builder.
func (m *UserThreadLikeMutation) Where(ps ...predicate.UserThreadLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserThreadLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserThreadLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserThreadLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserThreadLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserThreadLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserThreadLike).
func (m *UserThreadLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserThreadLikeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, userthreadlike.FieldUserID)
	}
	if m.thread != nil {
		fields = append(fields, userthreadlike.FieldThreadID)
	}
	if m.liked_at != nil {
		fields = append(fields, userthreadlike.FieldLikedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserThreadLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userthreadlike.FieldUserID:
		return m.UserID()
	case userthreadlike.FieldThreadID:
		return m.ThreadID()
	case userthreadlike.FieldLikedAt:
		return m.LikedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserThreadLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserThreadLike does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserThreadLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userthreadlike.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userthreadlike.FieldThreadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadID(v)
		return nil
	case userthreadlike.FieldLikedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserThreadLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserThreadLikeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserThreadLikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserThreadLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserThreadLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserThreadLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserThreadLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserThreadLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserThreadLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserThreadLikeMutation) ResetField(name string) error {
	switch name {
	case userthreadlike.FieldUserID:
		m.ResetUserID()
		return nil
	case userthreadlike.FieldThreadID:
		m.ResetThreadID()
		return nil
	case userthreadlike.FieldLikedAt:
		m.ResetLikedAt()
		return nil
	}
	return fmt.Errorf("unknown UserThreadLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserThreadLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userthreadlike.EdgeUser)
	}
	if m.thread != nil {
		edges = append(edges, userthreadlike.EdgeThread)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserThreadLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userthreadlike.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userthreadlike.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserThreadLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserThreadLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserThreadLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userthreadlike.EdgeUser)
	}
	if m.clearedthread {
		edges = append(edges, userthreadlike.EdgeThread)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserThreadLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case userthreadlike.EdgeUser:
		return m.cleareduser
	case userthreadlike.EdgeThread:
		return m.clearedthread
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserThreadLikeMutation) ClearEdge(name string) error {
	switch name {
	case userthreadlike.EdgeUser:
		m.ClearUser()
		return nil
	case userthreadlike.EdgeThread:
		m.ClearThread()
		return nil
	}
	return fmt.Errorf("unknown UserThreadLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserThreadLikeMutation) ResetEdge(name string) error {
	switch name {
	case userthreadlike.EdgeUser:
		m.ResetUser()
		return nil
	case userthreadlike.EdgeThread:
		m.ResetThread()
		return nil
	}
	return fmt.Errorf("unknown UserThreadLike edge %s", name)
}

// UserThreadSubscriptionMutation represents an operation that mutates the UserThreadSubscription nodes in the graph.
type UserThreadSubscriptionMutation struct {
	config
	op            Op
	typ           string
	is_notified   *bool
	is_checked    *bool
	subscribed_at *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	thread        *int
	clearedthread bool
	done          bool
	oldValue      func(context.Context) (*UserThreadSubscription, error)
	predicates    []predicate.UserThreadSubscription
}

var _ ent.Mutation = (*UserThreadSubscriptionMutation)(nil)

// userthreadsubscriptionOption allows management of the mutation configuration using functional options.
type userthreadsubscriptionOption func(*UserThreadSubscriptionMutation)

// newUserThreadSubscriptionMutation creates new mutation for the UserThreadSubscription entity.
func newUserThreadSubscriptionMutation(c config, op Op, opts ...userthreadsubscriptionOption) *UserThreadSubscriptionMutation {
	m := &UserThreadSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserThreadSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserThreadSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserThreadSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserID sets the "user_id" field.
func (m *UserThreadSubscriptionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserThreadSubscriptionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserThreadSubscriptionMutation) ResetUserID() {
	m.user = nil
}

// SetThreadID sets the "thread_id" field.
func (m *UserThreadSubscriptionMutation) SetThreadID(i int) {
	m.thread = &i
}

// ThreadID returns the value of the "thread_id" field in the mutation.
func (m *UserThreadSubscriptionMutation) ThreadID() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// ResetThreadID resets all changes to the "thread_id" field.
func (m *UserThreadSubscriptionMutation) ResetThreadID() {
	m.thread = nil
}

// SetIsNotified sets the "is_notified" field.
func (m *UserThreadSubscriptionMutation) SetIsNotified(b bool) {
	m.is_notified = &b
}

// IsNotified returns the value of the "is_notified" field in the mutation.
func (m *UserThreadSubscriptionMutation) IsNotified() (r bool, exists bool) {
	v := m.is_notified
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsNotified resets all changes to the "is_notified" field.
func (m *UserThreadSubscriptionMutation) ResetIsNotified() {
	m.is_notified = nil
}

// SetIsChecked sets the "is_checked" field.
func (m *UserThreadSubscriptionMutation) SetIsChecked(b bool) {
	m.is_checked = &b
}

// IsChecked returns the value of the "is_checked" field in the mutation.
func (m *UserThreadSubscriptionMutation) IsChecked() (r bool, exists bool) {
	v := m.is_checked
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsChecked resets all changes to the "is_checked" field.
func (m *UserThreadSubscriptionMutation) ResetIsChecked() {
	m.is_checked = nil
}

// SetSubscribedAt sets the "subscribed_at" field.
func (m *UserThreadSubscriptionMutation) SetSubscribedAt(t time.Time) {
	m.subscribed_at = &t
}

// SubscribedAt returns the value of the "subscribed_at" field in the mutation.
func (m *UserThreadSubscriptionMutation) SubscribedAt() (r time.Time, exists bool) {
	v := m.subscribed_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubscribedAt resets all changes to the "subscribed_at" field.
func (m *UserThreadSubscriptionMutation) ResetSubscribedAt() {
	m.subscribed_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserThreadSubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userthreadsubscription.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserThreadSubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserThreadSubscriptionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserThreadSubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *UserThreadSubscriptionMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[userthreadsubscription.FieldThreadID] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *UserThreadSubscriptionMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *UserThreadSubscriptionMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *UserThreadSubscriptionMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// Where appends a list predicates to the UserThreadSubscriptionMutation builder.
func (m *UserThreadSubscriptionMutation) Where(ps ...predicate.UserThreadSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserThreadSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserThreadSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserThreadSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserThreadSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserThreadSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserThreadSubscription).
func (m *UserThreadSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserThreadSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, userthreadsubscription.FieldUserID)
	}
	if m.thread != nil {
		fields = append(fields, userthreadsubscription.FieldThreadID)
	}
	if m.is_notified != nil {
		fields = append(fields, userthreadsubscription.FieldIsNotified)
	}
	if m.is_checked != nil {
		fields = append(fields, userthreadsubscription.FieldIsChecked)
	}
	if m.subscribed_at != nil {
		fields = append(fields, userthreadsubscription.FieldSubscribedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserThreadSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userthreadsubscription.FieldUserID:
		return m.UserID()
	case userthreadsubscription.FieldThreadID:
		return m.ThreadID()
	case userthreadsubscription.FieldIsNotified:
		return m.IsNotified()
	case userthreadsubscription.FieldIsChecked:
		return m.IsChecked()
	case userthreadsubscription.FieldSubscribedAt:
		return m.SubscribedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserThreadSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserThreadSubscription does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserThreadSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userthreadsubscription.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userthreadsubscription.FieldThreadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadID(v)
		return nil
	case userthreadsubscription.FieldIsNotified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNotified(v)
		return nil
	case userthreadsubscription.FieldIsChecked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsChecked(v)
		return nil
	case userthreadsubscription.FieldSubscribedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserThreadSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserThreadSubscriptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserThreadSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserThreadSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserThreadSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserThreadSubscriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserThreadSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserThreadSubscriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserThreadSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserThreadSubscriptionMutation) ResetField(name string) error {
	switch name {
	case userthreadsubscription.FieldUserID:
		m.ResetUserID()
		return nil
	case userthreadsubscription.FieldThreadID:
		m.ResetThreadID()
		return nil
	case userthreadsubscription.FieldIsNotified:
		m.ResetIsNotified()
		return nil
	case userthreadsubscription.FieldIsChecked:
		m.ResetIsChecked()
		return nil
	case userthreadsubscription.FieldSubscribedAt:
		m.ResetSubscribedAt()
		return nil
	}
	return fmt.Errorf("unknown UserThreadSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserThreadSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userthreadsubscription.EdgeUser)
	}
	if m.thread != nil {
		edges = append(edges, userthreadsubscription.EdgeThread)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserThreadSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userthreadsubscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userthreadsubscription.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserThreadSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserThreadSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserThreadSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userthreadsubscription.EdgeUser)
	}
	if m.clearedthread {
		edges = append(edges, userthreadsubscription.EdgeThread)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserThreadSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case userthreadsubscription.EdgeUser:
		return m.cleareduser
	case userthreadsubscription.EdgeThread:
		return m.clearedthread
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserThreadSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case userthreadsubscription.EdgeUser:
		m.ClearUser()
		return nil
	case userthreadsubscription.EdgeThread:
		m.ClearThread()
		return nil
	}
	return fmt.Errorf("unknown UserThreadSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserThreadSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case userthreadsubscription.EdgeUser:
		m.ResetUser()
		return nil
	case userthreadsubscription.EdgeThread:
		m.ResetThread()
		return nil
	}
	return fmt.Errorf("unknown UserThreadSubscription edge %s", name)
}
