// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"server/infrastructure/ent/migrate"

	"server/infrastructure/ent/board"
	"server/infrastructure/ent/contact"
	"server/infrastructure/ent/tag"
	"server/infrastructure/ent/thread"
	"server/infrastructure/ent/threadcomment"
	"server/infrastructure/ent/threadcommentattachment"
	"server/infrastructure/ent/threadtag"
	"server/infrastructure/ent/user"
	"server/infrastructure/ent/usercommentlike"
	"server/infrastructure/ent/userthreadlike"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Board is the client for interacting with the Board builders.
	Board *BoardClient
	// Contact is the client for interacting with the Contact builders.
	Contact *ContactClient
	// Tag is the client for interacting with the Tag builders.
	Tag *TagClient
	// Thread is the client for interacting with the Thread builders.
	Thread *ThreadClient
	// ThreadComment is the client for interacting with the ThreadComment builders.
	ThreadComment *ThreadCommentClient
	// ThreadCommentAttachment is the client for interacting with the ThreadCommentAttachment builders.
	ThreadCommentAttachment *ThreadCommentAttachmentClient
	// ThreadTag is the client for interacting with the ThreadTag builders.
	ThreadTag *ThreadTagClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserCommentLike is the client for interacting with the UserCommentLike builders.
	UserCommentLike *UserCommentLikeClient
	// UserThreadLike is the client for interacting with the UserThreadLike builders.
	UserThreadLike *UserThreadLikeClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Board = NewBoardClient(c.config)
	c.Contact = NewContactClient(c.config)
	c.Tag = NewTagClient(c.config)
	c.Thread = NewThreadClient(c.config)
	c.ThreadComment = NewThreadCommentClient(c.config)
	c.ThreadCommentAttachment = NewThreadCommentAttachmentClient(c.config)
	c.ThreadTag = NewThreadTagClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserCommentLike = NewUserCommentLikeClient(c.config)
	c.UserThreadLike = NewUserThreadLikeClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		Board:                   NewBoardClient(cfg),
		Contact:                 NewContactClient(cfg),
		Tag:                     NewTagClient(cfg),
		Thread:                  NewThreadClient(cfg),
		ThreadComment:           NewThreadCommentClient(cfg),
		ThreadCommentAttachment: NewThreadCommentAttachmentClient(cfg),
		ThreadTag:               NewThreadTagClient(cfg),
		User:                    NewUserClient(cfg),
		UserCommentLike:         NewUserCommentLikeClient(cfg),
		UserThreadLike:          NewUserThreadLikeClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		Board:                   NewBoardClient(cfg),
		Contact:                 NewContactClient(cfg),
		Tag:                     NewTagClient(cfg),
		Thread:                  NewThreadClient(cfg),
		ThreadComment:           NewThreadCommentClient(cfg),
		ThreadCommentAttachment: NewThreadCommentAttachmentClient(cfg),
		ThreadTag:               NewThreadTagClient(cfg),
		User:                    NewUserClient(cfg),
		UserCommentLike:         NewUserCommentLikeClient(cfg),
		UserThreadLike:          NewUserThreadLikeClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Board.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Board, c.Contact, c.Tag, c.Thread, c.ThreadComment, c.ThreadCommentAttachment,
		c.ThreadTag, c.User, c.UserCommentLike, c.UserThreadLike,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Board, c.Contact, c.Tag, c.Thread, c.ThreadComment, c.ThreadCommentAttachment,
		c.ThreadTag, c.User, c.UserCommentLike, c.UserThreadLike,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BoardMutation:
		return c.Board.mutate(ctx, m)
	case *ContactMutation:
		return c.Contact.mutate(ctx, m)
	case *TagMutation:
		return c.Tag.mutate(ctx, m)
	case *ThreadMutation:
		return c.Thread.mutate(ctx, m)
	case *ThreadCommentMutation:
		return c.ThreadComment.mutate(ctx, m)
	case *ThreadCommentAttachmentMutation:
		return c.ThreadCommentAttachment.mutate(ctx, m)
	case *ThreadTagMutation:
		return c.ThreadTag.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserCommentLikeMutation:
		return c.UserCommentLike.mutate(ctx, m)
	case *UserThreadLikeMutation:
		return c.UserThreadLike.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// BoardClient is a client for the Board schema.
type BoardClient struct {
	config
}

// NewBoardClient returns a client for the Board from the given config.
func NewBoardClient(c config) *BoardClient {
	return &BoardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `board.Hooks(f(g(h())))`.
func (c *BoardClient) Use(hooks ...Hook) {
	c.hooks.Board = append(c.hooks.Board, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `board.Intercept(f(g(h())))`.
func (c *BoardClient) Intercept(interceptors ...Interceptor) {
	c.inters.Board = append(c.inters.Board, interceptors...)
}

// Create returns a builder for creating a Board entity.
func (c *BoardClient) Create() *BoardCreate {
	mutation := newBoardMutation(c.config, OpCreate)
	return &BoardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Board entities.
func (c *BoardClient) CreateBulk(builders ...*BoardCreate) *BoardCreateBulk {
	return &BoardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BoardClient) MapCreateBulk(slice any, setFunc func(*BoardCreate, int)) *BoardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BoardCreateBulk{err: fmt.Errorf("calling to BoardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BoardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BoardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Board.
func (c *BoardClient) Update() *BoardUpdate {
	mutation := newBoardMutation(c.config, OpUpdate)
	return &BoardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BoardClient) UpdateOne(b *Board) *BoardUpdateOne {
	mutation := newBoardMutation(c.config, OpUpdateOne, withBoard(b))
	return &BoardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BoardClient) UpdateOneID(id int) *BoardUpdateOne {
	mutation := newBoardMutation(c.config, OpUpdateOne, withBoardID(id))
	return &BoardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Board.
func (c *BoardClient) Delete() *BoardDelete {
	mutation := newBoardMutation(c.config, OpDelete)
	return &BoardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BoardClient) DeleteOne(b *Board) *BoardDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BoardClient) DeleteOneID(id int) *BoardDeleteOne {
	builder := c.Delete().Where(board.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BoardDeleteOne{builder}
}

// Query returns a query builder for Board.
func (c *BoardClient) Query() *BoardQuery {
	return &BoardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBoard},
		inters: c.Interceptors(),
	}
}

// Get returns a Board entity by its id.
func (c *BoardClient) Get(ctx context.Context, id int) (*Board, error) {
	return c.Query().Where(board.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BoardClient) GetX(ctx context.Context, id int) *Board {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Board.
func (c *BoardClient) QueryOwner(b *Board) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(board.Table, board.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, board.OwnerTable, board.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThreads queries the threads edge of a Board.
func (c *BoardClient) QueryThreads(b *Board) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(board.Table, board.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, board.ThreadsTable, board.ThreadsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BoardClient) Hooks() []Hook {
	return c.hooks.Board
}

// Interceptors returns the client interceptors.
func (c *BoardClient) Interceptors() []Interceptor {
	return c.inters.Board
}

func (c *BoardClient) mutate(ctx context.Context, m *BoardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BoardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BoardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BoardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BoardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Board mutation op: %q", m.Op())
	}
}

// ContactClient is a client for the Contact schema.
type ContactClient struct {
	config
}

// NewContactClient returns a client for the Contact from the given config.
func NewContactClient(c config) *ContactClient {
	return &ContactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contact.Hooks(f(g(h())))`.
func (c *ContactClient) Use(hooks ...Hook) {
	c.hooks.Contact = append(c.hooks.Contact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contact.Intercept(f(g(h())))`.
func (c *ContactClient) Intercept(interceptors ...Interceptor) {
	c.inters.Contact = append(c.inters.Contact, interceptors...)
}

// Create returns a builder for creating a Contact entity.
func (c *ContactClient) Create() *ContactCreate {
	mutation := newContactMutation(c.config, OpCreate)
	return &ContactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Contact entities.
func (c *ContactClient) CreateBulk(builders ...*ContactCreate) *ContactCreateBulk {
	return &ContactCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContactClient) MapCreateBulk(slice any, setFunc func(*ContactCreate, int)) *ContactCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContactCreateBulk{err: fmt.Errorf("calling to ContactClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContactCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Contact.
func (c *ContactClient) Update() *ContactUpdate {
	mutation := newContactMutation(c.config, OpUpdate)
	return &ContactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContactClient) UpdateOne(co *Contact) *ContactUpdateOne {
	mutation := newContactMutation(c.config, OpUpdateOne, withContact(co))
	return &ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContactClient) UpdateOneID(id int) *ContactUpdateOne {
	mutation := newContactMutation(c.config, OpUpdateOne, withContactID(id))
	return &ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Contact.
func (c *ContactClient) Delete() *ContactDelete {
	mutation := newContactMutation(c.config, OpDelete)
	return &ContactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContactClient) DeleteOne(co *Contact) *ContactDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContactClient) DeleteOneID(id int) *ContactDeleteOne {
	builder := c.Delete().Where(contact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContactDeleteOne{builder}
}

// Query returns a query builder for Contact.
func (c *ContactClient) Query() *ContactQuery {
	return &ContactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContact},
		inters: c.Interceptors(),
	}
}

// Get returns a Contact entity by its id.
func (c *ContactClient) Get(ctx context.Context, id int) (*Contact, error) {
	return c.Query().Where(contact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContactClient) GetX(ctx context.Context, id int) *Contact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ContactClient) Hooks() []Hook {
	return c.hooks.Contact
}

// Interceptors returns the client interceptors.
func (c *ContactClient) Interceptors() []Interceptor {
	return c.inters.Contact
}

func (c *ContactClient) mutate(ctx context.Context, m *ContactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Contact mutation op: %q", m.Op())
	}
}

// TagClient is a client for the Tag schema.
type TagClient struct {
	config
}

// NewTagClient returns a client for the Tag from the given config.
func NewTagClient(c config) *TagClient {
	return &TagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tag.Hooks(f(g(h())))`.
func (c *TagClient) Use(hooks ...Hook) {
	c.hooks.Tag = append(c.hooks.Tag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tag.Intercept(f(g(h())))`.
func (c *TagClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tag = append(c.inters.Tag, interceptors...)
}

// Create returns a builder for creating a Tag entity.
func (c *TagClient) Create() *TagCreate {
	mutation := newTagMutation(c.config, OpCreate)
	return &TagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tag entities.
func (c *TagClient) CreateBulk(builders ...*TagCreate) *TagCreateBulk {
	return &TagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TagClient) MapCreateBulk(slice any, setFunc func(*TagCreate, int)) *TagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TagCreateBulk{err: fmt.Errorf("calling to TagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tag.
func (c *TagClient) Update() *TagUpdate {
	mutation := newTagMutation(c.config, OpUpdate)
	return &TagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TagClient) UpdateOne(t *Tag) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTag(t))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TagClient) UpdateOneID(id int) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTagID(id))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tag.
func (c *TagClient) Delete() *TagDelete {
	mutation := newTagMutation(c.config, OpDelete)
	return &TagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TagClient) DeleteOne(t *Tag) *TagDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TagClient) DeleteOneID(id int) *TagDeleteOne {
	builder := c.Delete().Where(tag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TagDeleteOne{builder}
}

// Query returns a query builder for Tag.
func (c *TagClient) Query() *TagQuery {
	return &TagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTag},
		inters: c.Interceptors(),
	}
}

// Get returns a Tag entity by its id.
func (c *TagClient) Get(ctx context.Context, id int) (*Tag, error) {
	return c.Query().Where(tag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TagClient) GetX(ctx context.Context, id int) *Tag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryThreads queries the threads edge of a Tag.
func (c *TagClient) QueryThreads(t *Tag) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, tag.ThreadsTable, tag.ThreadsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThreadTags queries the thread_tags edge of a Tag.
func (c *TagClient) QueryThreadTags(t *Tag) *ThreadTagQuery {
	query := (&ThreadTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(threadtag.Table, threadtag.TagColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, tag.ThreadTagsTable, tag.ThreadTagsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TagClient) Hooks() []Hook {
	return c.hooks.Tag
}

// Interceptors returns the client interceptors.
func (c *TagClient) Interceptors() []Interceptor {
	return c.inters.Tag
}

func (c *TagClient) mutate(ctx context.Context, m *TagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tag mutation op: %q", m.Op())
	}
}

// ThreadClient is a client for the Thread schema.
type ThreadClient struct {
	config
}

// NewThreadClient returns a client for the Thread from the given config.
func NewThreadClient(c config) *ThreadClient {
	return &ThreadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `thread.Hooks(f(g(h())))`.
func (c *ThreadClient) Use(hooks ...Hook) {
	c.hooks.Thread = append(c.hooks.Thread, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `thread.Intercept(f(g(h())))`.
func (c *ThreadClient) Intercept(interceptors ...Interceptor) {
	c.inters.Thread = append(c.inters.Thread, interceptors...)
}

// Create returns a builder for creating a Thread entity.
func (c *ThreadClient) Create() *ThreadCreate {
	mutation := newThreadMutation(c.config, OpCreate)
	return &ThreadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Thread entities.
func (c *ThreadClient) CreateBulk(builders ...*ThreadCreate) *ThreadCreateBulk {
	return &ThreadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ThreadClient) MapCreateBulk(slice any, setFunc func(*ThreadCreate, int)) *ThreadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ThreadCreateBulk{err: fmt.Errorf("calling to ThreadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ThreadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ThreadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Thread.
func (c *ThreadClient) Update() *ThreadUpdate {
	mutation := newThreadMutation(c.config, OpUpdate)
	return &ThreadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ThreadClient) UpdateOne(t *Thread) *ThreadUpdateOne {
	mutation := newThreadMutation(c.config, OpUpdateOne, withThread(t))
	return &ThreadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ThreadClient) UpdateOneID(id int) *ThreadUpdateOne {
	mutation := newThreadMutation(c.config, OpUpdateOne, withThreadID(id))
	return &ThreadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Thread.
func (c *ThreadClient) Delete() *ThreadDelete {
	mutation := newThreadMutation(c.config, OpDelete)
	return &ThreadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ThreadClient) DeleteOne(t *Thread) *ThreadDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ThreadClient) DeleteOneID(id int) *ThreadDeleteOne {
	builder := c.Delete().Where(thread.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ThreadDeleteOne{builder}
}

// Query returns a query builder for Thread.
func (c *ThreadClient) Query() *ThreadQuery {
	return &ThreadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeThread},
		inters: c.Interceptors(),
	}
}

// Get returns a Thread entity by its id.
func (c *ThreadClient) Get(ctx context.Context, id int) (*Thread, error) {
	return c.Query().Where(thread.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ThreadClient) GetX(ctx context.Context, id int) *Thread {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBoard queries the board edge of a Thread.
func (c *ThreadClient) QueryBoard(t *Thread) *BoardQuery {
	query := (&BoardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(board.Table, board.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, thread.BoardTable, thread.BoardColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a Thread.
func (c *ThreadClient) QueryOwner(t *Thread) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, thread.OwnerTable, thread.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Thread.
func (c *ThreadClient) QueryComments(t *Thread) *ThreadCommentQuery {
	query := (&ThreadCommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(threadcomment.Table, threadcomment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, thread.CommentsTable, thread.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a Thread.
func (c *ThreadClient) QueryTags(t *Thread) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, thread.TagsTable, thread.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedUsers queries the liked_users edge of a Thread.
func (c *ThreadClient) QueryLikedUsers(t *Thread) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, thread.LikedUsersTable, thread.LikedUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThreadTags queries the thread_tags edge of a Thread.
func (c *ThreadClient) QueryThreadTags(t *Thread) *ThreadTagQuery {
	query := (&ThreadTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(threadtag.Table, threadtag.ThreadColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, thread.ThreadTagsTable, thread.ThreadTagsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserThreadLike queries the user_thread_like edge of a Thread.
func (c *ThreadClient) QueryUserThreadLike(t *Thread) *UserThreadLikeQuery {
	query := (&UserThreadLikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(userthreadlike.Table, userthreadlike.ThreadColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, thread.UserThreadLikeTable, thread.UserThreadLikeColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ThreadClient) Hooks() []Hook {
	return c.hooks.Thread
}

// Interceptors returns the client interceptors.
func (c *ThreadClient) Interceptors() []Interceptor {
	return c.inters.Thread
}

func (c *ThreadClient) mutate(ctx context.Context, m *ThreadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ThreadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ThreadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ThreadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ThreadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Thread mutation op: %q", m.Op())
	}
}

// ThreadCommentClient is a client for the ThreadComment schema.
type ThreadCommentClient struct {
	config
}

// NewThreadCommentClient returns a client for the ThreadComment from the given config.
func NewThreadCommentClient(c config) *ThreadCommentClient {
	return &ThreadCommentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `threadcomment.Hooks(f(g(h())))`.
func (c *ThreadCommentClient) Use(hooks ...Hook) {
	c.hooks.ThreadComment = append(c.hooks.ThreadComment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `threadcomment.Intercept(f(g(h())))`.
func (c *ThreadCommentClient) Intercept(interceptors ...Interceptor) {
	c.inters.ThreadComment = append(c.inters.ThreadComment, interceptors...)
}

// Create returns a builder for creating a ThreadComment entity.
func (c *ThreadCommentClient) Create() *ThreadCommentCreate {
	mutation := newThreadCommentMutation(c.config, OpCreate)
	return &ThreadCommentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ThreadComment entities.
func (c *ThreadCommentClient) CreateBulk(builders ...*ThreadCommentCreate) *ThreadCommentCreateBulk {
	return &ThreadCommentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ThreadCommentClient) MapCreateBulk(slice any, setFunc func(*ThreadCommentCreate, int)) *ThreadCommentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ThreadCommentCreateBulk{err: fmt.Errorf("calling to ThreadCommentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ThreadCommentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ThreadCommentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ThreadComment.
func (c *ThreadCommentClient) Update() *ThreadCommentUpdate {
	mutation := newThreadCommentMutation(c.config, OpUpdate)
	return &ThreadCommentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ThreadCommentClient) UpdateOne(tc *ThreadComment) *ThreadCommentUpdateOne {
	mutation := newThreadCommentMutation(c.config, OpUpdateOne, withThreadComment(tc))
	return &ThreadCommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ThreadCommentClient) UpdateOneID(id int) *ThreadCommentUpdateOne {
	mutation := newThreadCommentMutation(c.config, OpUpdateOne, withThreadCommentID(id))
	return &ThreadCommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ThreadComment.
func (c *ThreadCommentClient) Delete() *ThreadCommentDelete {
	mutation := newThreadCommentMutation(c.config, OpDelete)
	return &ThreadCommentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ThreadCommentClient) DeleteOne(tc *ThreadComment) *ThreadCommentDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ThreadCommentClient) DeleteOneID(id int) *ThreadCommentDeleteOne {
	builder := c.Delete().Where(threadcomment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ThreadCommentDeleteOne{builder}
}

// Query returns a query builder for ThreadComment.
func (c *ThreadCommentClient) Query() *ThreadCommentQuery {
	return &ThreadCommentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeThreadComment},
		inters: c.Interceptors(),
	}
}

// Get returns a ThreadComment entity by its id.
func (c *ThreadCommentClient) Get(ctx context.Context, id int) (*ThreadComment, error) {
	return c.Query().Where(threadcomment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ThreadCommentClient) GetX(ctx context.Context, id int) *ThreadComment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryThread queries the thread edge of a ThreadComment.
func (c *ThreadCommentClient) QueryThread(tc *ThreadComment) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(threadcomment.Table, threadcomment.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, threadcomment.ThreadTable, threadcomment.ThreadColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthor queries the author edge of a ThreadComment.
func (c *ThreadCommentClient) QueryAuthor(tc *ThreadComment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(threadcomment.Table, threadcomment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, threadcomment.AuthorTable, threadcomment.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentComment queries the parent_comment edge of a ThreadComment.
func (c *ThreadCommentClient) QueryParentComment(tc *ThreadComment) *ThreadCommentQuery {
	query := (&ThreadCommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(threadcomment.Table, threadcomment.FieldID, id),
			sqlgraph.To(threadcomment.Table, threadcomment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, threadcomment.ParentCommentTable, threadcomment.ParentCommentColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReplies queries the replies edge of a ThreadComment.
func (c *ThreadCommentClient) QueryReplies(tc *ThreadComment) *ThreadCommentQuery {
	query := (&ThreadCommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(threadcomment.Table, threadcomment.FieldID, id),
			sqlgraph.To(threadcomment.Table, threadcomment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, threadcomment.RepliesTable, threadcomment.RepliesColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttachments queries the attachments edge of a ThreadComment.
func (c *ThreadCommentClient) QueryAttachments(tc *ThreadComment) *ThreadCommentAttachmentQuery {
	query := (&ThreadCommentAttachmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(threadcomment.Table, threadcomment.FieldID, id),
			sqlgraph.To(threadcommentattachment.Table, threadcommentattachment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, threadcomment.AttachmentsTable, threadcomment.AttachmentsColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedUsers queries the liked_users edge of a ThreadComment.
func (c *ThreadCommentClient) QueryLikedUsers(tc *ThreadComment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(threadcomment.Table, threadcomment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, threadcomment.LikedUsersTable, threadcomment.LikedUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserCommentLike queries the user_comment_like edge of a ThreadComment.
func (c *ThreadCommentClient) QueryUserCommentLike(tc *ThreadComment) *UserCommentLikeQuery {
	query := (&UserCommentLikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(threadcomment.Table, threadcomment.FieldID, id),
			sqlgraph.To(usercommentlike.Table, usercommentlike.CommentColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, threadcomment.UserCommentLikeTable, threadcomment.UserCommentLikeColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ThreadCommentClient) Hooks() []Hook {
	return c.hooks.ThreadComment
}

// Interceptors returns the client interceptors.
func (c *ThreadCommentClient) Interceptors() []Interceptor {
	return c.inters.ThreadComment
}

func (c *ThreadCommentClient) mutate(ctx context.Context, m *ThreadCommentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ThreadCommentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ThreadCommentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ThreadCommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ThreadCommentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ThreadComment mutation op: %q", m.Op())
	}
}

// ThreadCommentAttachmentClient is a client for the ThreadCommentAttachment schema.
type ThreadCommentAttachmentClient struct {
	config
}

// NewThreadCommentAttachmentClient returns a client for the ThreadCommentAttachment from the given config.
func NewThreadCommentAttachmentClient(c config) *ThreadCommentAttachmentClient {
	return &ThreadCommentAttachmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `threadcommentattachment.Hooks(f(g(h())))`.
func (c *ThreadCommentAttachmentClient) Use(hooks ...Hook) {
	c.hooks.ThreadCommentAttachment = append(c.hooks.ThreadCommentAttachment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `threadcommentattachment.Intercept(f(g(h())))`.
func (c *ThreadCommentAttachmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.ThreadCommentAttachment = append(c.inters.ThreadCommentAttachment, interceptors...)
}

// Create returns a builder for creating a ThreadCommentAttachment entity.
func (c *ThreadCommentAttachmentClient) Create() *ThreadCommentAttachmentCreate {
	mutation := newThreadCommentAttachmentMutation(c.config, OpCreate)
	return &ThreadCommentAttachmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ThreadCommentAttachment entities.
func (c *ThreadCommentAttachmentClient) CreateBulk(builders ...*ThreadCommentAttachmentCreate) *ThreadCommentAttachmentCreateBulk {
	return &ThreadCommentAttachmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ThreadCommentAttachmentClient) MapCreateBulk(slice any, setFunc func(*ThreadCommentAttachmentCreate, int)) *ThreadCommentAttachmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ThreadCommentAttachmentCreateBulk{err: fmt.Errorf("calling to ThreadCommentAttachmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ThreadCommentAttachmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ThreadCommentAttachmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ThreadCommentAttachment.
func (c *ThreadCommentAttachmentClient) Update() *ThreadCommentAttachmentUpdate {
	mutation := newThreadCommentAttachmentMutation(c.config, OpUpdate)
	return &ThreadCommentAttachmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ThreadCommentAttachmentClient) UpdateOne(tca *ThreadCommentAttachment) *ThreadCommentAttachmentUpdateOne {
	mutation := newThreadCommentAttachmentMutation(c.config, OpUpdateOne, withThreadCommentAttachment(tca))
	return &ThreadCommentAttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ThreadCommentAttachmentClient) UpdateOneID(id int) *ThreadCommentAttachmentUpdateOne {
	mutation := newThreadCommentAttachmentMutation(c.config, OpUpdateOne, withThreadCommentAttachmentID(id))
	return &ThreadCommentAttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ThreadCommentAttachment.
func (c *ThreadCommentAttachmentClient) Delete() *ThreadCommentAttachmentDelete {
	mutation := newThreadCommentAttachmentMutation(c.config, OpDelete)
	return &ThreadCommentAttachmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ThreadCommentAttachmentClient) DeleteOne(tca *ThreadCommentAttachment) *ThreadCommentAttachmentDeleteOne {
	return c.DeleteOneID(tca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ThreadCommentAttachmentClient) DeleteOneID(id int) *ThreadCommentAttachmentDeleteOne {
	builder := c.Delete().Where(threadcommentattachment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ThreadCommentAttachmentDeleteOne{builder}
}

// Query returns a query builder for ThreadCommentAttachment.
func (c *ThreadCommentAttachmentClient) Query() *ThreadCommentAttachmentQuery {
	return &ThreadCommentAttachmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeThreadCommentAttachment},
		inters: c.Interceptors(),
	}
}

// Get returns a ThreadCommentAttachment entity by its id.
func (c *ThreadCommentAttachmentClient) Get(ctx context.Context, id int) (*ThreadCommentAttachment, error) {
	return c.Query().Where(threadcommentattachment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ThreadCommentAttachmentClient) GetX(ctx context.Context, id int) *ThreadCommentAttachment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComment queries the comment edge of a ThreadCommentAttachment.
func (c *ThreadCommentAttachmentClient) QueryComment(tca *ThreadCommentAttachment) *ThreadCommentQuery {
	query := (&ThreadCommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(threadcommentattachment.Table, threadcommentattachment.FieldID, id),
			sqlgraph.To(threadcomment.Table, threadcomment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, threadcommentattachment.CommentTable, threadcommentattachment.CommentColumn),
		)
		fromV = sqlgraph.Neighbors(tca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ThreadCommentAttachmentClient) Hooks() []Hook {
	return c.hooks.ThreadCommentAttachment
}

// Interceptors returns the client interceptors.
func (c *ThreadCommentAttachmentClient) Interceptors() []Interceptor {
	return c.inters.ThreadCommentAttachment
}

func (c *ThreadCommentAttachmentClient) mutate(ctx context.Context, m *ThreadCommentAttachmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ThreadCommentAttachmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ThreadCommentAttachmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ThreadCommentAttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ThreadCommentAttachmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ThreadCommentAttachment mutation op: %q", m.Op())
	}
}

// ThreadTagClient is a client for the ThreadTag schema.
type ThreadTagClient struct {
	config
}

// NewThreadTagClient returns a client for the ThreadTag from the given config.
func NewThreadTagClient(c config) *ThreadTagClient {
	return &ThreadTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `threadtag.Hooks(f(g(h())))`.
func (c *ThreadTagClient) Use(hooks ...Hook) {
	c.hooks.ThreadTag = append(c.hooks.ThreadTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `threadtag.Intercept(f(g(h())))`.
func (c *ThreadTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.ThreadTag = append(c.inters.ThreadTag, interceptors...)
}

// Create returns a builder for creating a ThreadTag entity.
func (c *ThreadTagClient) Create() *ThreadTagCreate {
	mutation := newThreadTagMutation(c.config, OpCreate)
	return &ThreadTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ThreadTag entities.
func (c *ThreadTagClient) CreateBulk(builders ...*ThreadTagCreate) *ThreadTagCreateBulk {
	return &ThreadTagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ThreadTagClient) MapCreateBulk(slice any, setFunc func(*ThreadTagCreate, int)) *ThreadTagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ThreadTagCreateBulk{err: fmt.Errorf("calling to ThreadTagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ThreadTagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ThreadTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ThreadTag.
func (c *ThreadTagClient) Update() *ThreadTagUpdate {
	mutation := newThreadTagMutation(c.config, OpUpdate)
	return &ThreadTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ThreadTagClient) UpdateOne(tt *ThreadTag) *ThreadTagUpdateOne {
	mutation := newThreadTagMutation(c.config, OpUpdateOne)
	mutation.thread = &tt.ThreadID
	mutation.tag = &tt.TagID
	return &ThreadTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ThreadTag.
func (c *ThreadTagClient) Delete() *ThreadTagDelete {
	mutation := newThreadTagMutation(c.config, OpDelete)
	return &ThreadTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for ThreadTag.
func (c *ThreadTagClient) Query() *ThreadTagQuery {
	return &ThreadTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeThreadTag},
		inters: c.Interceptors(),
	}
}

// QueryThread queries the thread edge of a ThreadTag.
func (c *ThreadTagClient) QueryThread(tt *ThreadTag) *ThreadQuery {
	return c.Query().
		Where(threadtag.ThreadID(tt.ThreadID), threadtag.TagID(tt.TagID)).
		QueryThread()
}

// QueryTag queries the tag edge of a ThreadTag.
func (c *ThreadTagClient) QueryTag(tt *ThreadTag) *TagQuery {
	return c.Query().
		Where(threadtag.ThreadID(tt.ThreadID), threadtag.TagID(tt.TagID)).
		QueryTag()
}

// Hooks returns the client hooks.
func (c *ThreadTagClient) Hooks() []Hook {
	return c.hooks.ThreadTag
}

// Interceptors returns the client interceptors.
func (c *ThreadTagClient) Interceptors() []Interceptor {
	return c.inters.ThreadTag
}

func (c *ThreadTagClient) mutate(ctx context.Context, m *ThreadTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ThreadTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ThreadTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ThreadTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ThreadTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ThreadTag mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBoards queries the boards edge of a User.
func (c *UserClient) QueryBoards(u *User) *BoardQuery {
	query := (&BoardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(board.Table, board.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BoardsTable, user.BoardsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThreads queries the threads edge of a User.
func (c *UserClient) QueryThreads(u *User) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ThreadsTable, user.ThreadsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a User.
func (c *UserClient) QueryComments(u *User) *ThreadCommentQuery {
	query := (&ThreadCommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(threadcomment.Table, threadcomment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CommentsTable, user.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedThreads queries the liked_threads edge of a User.
func (c *UserClient) QueryLikedThreads(u *User) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.LikedThreadsTable, user.LikedThreadsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedComments queries the liked_comments edge of a User.
func (c *UserClient) QueryLikedComments(u *User) *ThreadCommentQuery {
	query := (&ThreadCommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(threadcomment.Table, threadcomment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.LikedCommentsTable, user.LikedCommentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserThreadLike queries the user_thread_like edge of a User.
func (c *UserClient) QueryUserThreadLike(u *User) *UserThreadLikeQuery {
	query := (&UserThreadLikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userthreadlike.Table, userthreadlike.UserColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserThreadLikeTable, user.UserThreadLikeColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserCommentLike queries the user_comment_like edge of a User.
func (c *UserClient) QueryUserCommentLike(u *User) *UserCommentLikeQuery {
	query := (&UserCommentLikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usercommentlike.Table, usercommentlike.UserColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserCommentLikeTable, user.UserCommentLikeColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserCommentLikeClient is a client for the UserCommentLike schema.
type UserCommentLikeClient struct {
	config
}

// NewUserCommentLikeClient returns a client for the UserCommentLike from the given config.
func NewUserCommentLikeClient(c config) *UserCommentLikeClient {
	return &UserCommentLikeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usercommentlike.Hooks(f(g(h())))`.
func (c *UserCommentLikeClient) Use(hooks ...Hook) {
	c.hooks.UserCommentLike = append(c.hooks.UserCommentLike, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usercommentlike.Intercept(f(g(h())))`.
func (c *UserCommentLikeClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserCommentLike = append(c.inters.UserCommentLike, interceptors...)
}

// Create returns a builder for creating a UserCommentLike entity.
func (c *UserCommentLikeClient) Create() *UserCommentLikeCreate {
	mutation := newUserCommentLikeMutation(c.config, OpCreate)
	return &UserCommentLikeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserCommentLike entities.
func (c *UserCommentLikeClient) CreateBulk(builders ...*UserCommentLikeCreate) *UserCommentLikeCreateBulk {
	return &UserCommentLikeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserCommentLikeClient) MapCreateBulk(slice any, setFunc func(*UserCommentLikeCreate, int)) *UserCommentLikeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCommentLikeCreateBulk{err: fmt.Errorf("calling to UserCommentLikeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCommentLikeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCommentLikeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserCommentLike.
func (c *UserCommentLikeClient) Update() *UserCommentLikeUpdate {
	mutation := newUserCommentLikeMutation(c.config, OpUpdate)
	return &UserCommentLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserCommentLikeClient) UpdateOne(ucl *UserCommentLike) *UserCommentLikeUpdateOne {
	mutation := newUserCommentLikeMutation(c.config, OpUpdateOne)
	mutation.user = &ucl.UserID
	mutation.comment = &ucl.CommentID
	return &UserCommentLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserCommentLike.
func (c *UserCommentLikeClient) Delete() *UserCommentLikeDelete {
	mutation := newUserCommentLikeMutation(c.config, OpDelete)
	return &UserCommentLikeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for UserCommentLike.
func (c *UserCommentLikeClient) Query() *UserCommentLikeQuery {
	return &UserCommentLikeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserCommentLike},
		inters: c.Interceptors(),
	}
}

// QueryUser queries the user edge of a UserCommentLike.
func (c *UserCommentLikeClient) QueryUser(ucl *UserCommentLike) *UserQuery {
	return c.Query().
		Where(usercommentlike.UserID(ucl.UserID), usercommentlike.CommentID(ucl.CommentID)).
		QueryUser()
}

// QueryComment queries the comment edge of a UserCommentLike.
func (c *UserCommentLikeClient) QueryComment(ucl *UserCommentLike) *ThreadCommentQuery {
	return c.Query().
		Where(usercommentlike.UserID(ucl.UserID), usercommentlike.CommentID(ucl.CommentID)).
		QueryComment()
}

// Hooks returns the client hooks.
func (c *UserCommentLikeClient) Hooks() []Hook {
	return c.hooks.UserCommentLike
}

// Interceptors returns the client interceptors.
func (c *UserCommentLikeClient) Interceptors() []Interceptor {
	return c.inters.UserCommentLike
}

func (c *UserCommentLikeClient) mutate(ctx context.Context, m *UserCommentLikeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCommentLikeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserCommentLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserCommentLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserCommentLikeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserCommentLike mutation op: %q", m.Op())
	}
}

// UserThreadLikeClient is a client for the UserThreadLike schema.
type UserThreadLikeClient struct {
	config
}

// NewUserThreadLikeClient returns a client for the UserThreadLike from the given config.
func NewUserThreadLikeClient(c config) *UserThreadLikeClient {
	return &UserThreadLikeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userthreadlike.Hooks(f(g(h())))`.
func (c *UserThreadLikeClient) Use(hooks ...Hook) {
	c.hooks.UserThreadLike = append(c.hooks.UserThreadLike, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userthreadlike.Intercept(f(g(h())))`.
func (c *UserThreadLikeClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserThreadLike = append(c.inters.UserThreadLike, interceptors...)
}

// Create returns a builder for creating a UserThreadLike entity.
func (c *UserThreadLikeClient) Create() *UserThreadLikeCreate {
	mutation := newUserThreadLikeMutation(c.config, OpCreate)
	return &UserThreadLikeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserThreadLike entities.
func (c *UserThreadLikeClient) CreateBulk(builders ...*UserThreadLikeCreate) *UserThreadLikeCreateBulk {
	return &UserThreadLikeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserThreadLikeClient) MapCreateBulk(slice any, setFunc func(*UserThreadLikeCreate, int)) *UserThreadLikeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserThreadLikeCreateBulk{err: fmt.Errorf("calling to UserThreadLikeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserThreadLikeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserThreadLikeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserThreadLike.
func (c *UserThreadLikeClient) Update() *UserThreadLikeUpdate {
	mutation := newUserThreadLikeMutation(c.config, OpUpdate)
	return &UserThreadLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserThreadLikeClient) UpdateOne(utl *UserThreadLike) *UserThreadLikeUpdateOne {
	mutation := newUserThreadLikeMutation(c.config, OpUpdateOne)
	mutation.user = &utl.UserID
	mutation.thread = &utl.ThreadID
	return &UserThreadLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserThreadLike.
func (c *UserThreadLikeClient) Delete() *UserThreadLikeDelete {
	mutation := newUserThreadLikeMutation(c.config, OpDelete)
	return &UserThreadLikeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for UserThreadLike.
func (c *UserThreadLikeClient) Query() *UserThreadLikeQuery {
	return &UserThreadLikeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserThreadLike},
		inters: c.Interceptors(),
	}
}

// QueryUser queries the user edge of a UserThreadLike.
func (c *UserThreadLikeClient) QueryUser(utl *UserThreadLike) *UserQuery {
	return c.Query().
		Where(userthreadlike.UserID(utl.UserID), userthreadlike.ThreadID(utl.ThreadID)).
		QueryUser()
}

// QueryThread queries the thread edge of a UserThreadLike.
func (c *UserThreadLikeClient) QueryThread(utl *UserThreadLike) *ThreadQuery {
	return c.Query().
		Where(userthreadlike.UserID(utl.UserID), userthreadlike.ThreadID(utl.ThreadID)).
		QueryThread()
}

// Hooks returns the client hooks.
func (c *UserThreadLikeClient) Hooks() []Hook {
	return c.hooks.UserThreadLike
}

// Interceptors returns the client interceptors.
func (c *UserThreadLikeClient) Interceptors() []Interceptor {
	return c.inters.UserThreadLike
}

func (c *UserThreadLikeClient) mutate(ctx context.Context, m *UserThreadLikeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserThreadLikeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserThreadLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserThreadLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserThreadLikeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserThreadLike mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Board, Contact, Tag, Thread, ThreadComment, ThreadCommentAttachment, ThreadTag,
		User, UserCommentLike, UserThreadLike []ent.Hook
	}
	inters struct {
		Board, Contact, Tag, Thread, ThreadComment, ThreadCommentAttachment, ThreadTag,
		User, UserCommentLike, UserThreadLike []ent.Interceptor
	}
)
